CLI Options Intro - Typer Typer CLI Options Intro Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes CLI Options Intro In the next short sections we will see how to modify CLI options using typer.Option() . typer.Option() works very similarly to typer.Argument() , but has some extra features that we'll see next. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Password CLI Option and Confirmation Prompt - Typer Skip to content Typer Password CLI Option and Confirmation Prompt Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt Password CLI Option and Confirmation Prompt Table of contents A Password prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents A Password prompt Password CLI Option and Confirmation Prompt Apart from having a prompt, you can make a CLI option have a confirmation_prompt=True : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : str , email : Annotated [ str , typer . Option ( prompt = True , confirmation_prompt = True )], ): print ( f "Hello { name } , your email is { email } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str , email : str = typer . Option ( ... , prompt = True , confirmation_prompt = True ) ): print ( f "Hello { name } , your email is { email } " ) if __name__ == "__main__" : typer . run ( main ) And the CLI program will ask for confirmation: $ python main.py Camila // It prompts for the email # Email: $ camila@example.com # Repeat for confirmation: $ camila@example.com Hello Camila, your email is camila@example.com A Password prompt ¬∂ When receiving a password, it is very common (in most shells) to not show anything on the screen while typing the password. The program will still receive the password, but nothing will be shown on screen, not even **** . You can achieve the same using hide_input=True . And if you combine it with confirmation_prompt=True you can easily receive a password with double confirmation: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : str , password : Annotated [ str , typer . Option ( prompt = True , confirmation_prompt = True , hide_input = True ) ], ): print ( f "Hello { name } . Doing something very secure with password." ) print ( f "...just kidding, here it is, very insecure: { password } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str , password : str = typer . Option ( ... , prompt = True , confirmation_prompt = True , hide_input = True ), ): print ( f "Hello { name } . Doing something very secure with password." ) print ( f "...just kidding, here it is, very insecure: { password } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py Camila // It prompts for the password, but doesn't show anything when you type # Password: $ # Repeat for confirmation: $ // Let's imagine the password typed was "typerrocks" Hello Camila. Doing something very secure with password. ...just kidding, here it is, very insecure: typerrocks Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Option Callback and Context - Typer Skip to content Typer CLI Option Callback and Context Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context CLI Option Callback and Context Table of contents Validate CLI parameters Handling completion How shell completion works Breaking completion in a callback Fix completion - using the Context Using the CallbackParam object Technical Details Click's Parameter Callback with type annotations value function parameter Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Validate CLI parameters Handling completion How shell completion works Breaking completion in a callback Fix completion - using the Context Using the CallbackParam object Technical Details Click's Parameter Callback with type annotations value function parameter CLI Option Callback and Context In some occasions you might want to have some custom logic for a specific CLI parameter (for a CLI option or CLI argument ) that is executed with the value received from the terminal. In those cases you can use a CLI parameter callback function. Validate CLI parameters ¬∂ For example, you could do some validation before the rest of the code is executed. Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def name_callback ( value : str ): if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : Annotated [ str , typer . Option ( callback = name_callback )]): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def name_callback ( value : str ): if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Here you pass a function to typer.Option() or typer.Argument() with the keyword argument callback . The function receives the value from the command line. It can do anything with it, and then return the value. In this case, if the --name is not Camila we raise a typer.BadParameter() exception. The BadParameter exception is special, it shows the error with the parameter that generated it. Check it: $ python main.py --name Camila Hello Camila $ python main.py --name Rick Usage: main.py [OPTIONS] // We get the error from the callback Error: Invalid value for '--name': Only Camila is allowed Handling completion ¬∂ There's something to be aware of with callbacks and completion that requires some small special handling. But first let's just use completion in your shell (Bash, Zsh, Fish, or PowerShell). After installing completion (for your own Python package or for Typer CLI ), when you use your CLI program and start adding a CLI option with -- an then hit TAB , your shell will show you the available CLI options (the same for CLI arguments , etc). To check it quickly without creating a new Python package, install Typer CLI and use it with the previous script: // Hit the TAB key in your keyboard below where you see the: [TAB] $ typer ./main.py [ TAB ][ TAB ] // Depending on your terminal/shell you will get some completion like this ‚ú® run    -- Run the provided Typer app. utils  -- Extra utility commands for Typer apps. // Then try with "run" and --help $ typer ./main.py run --help // You get a help text with your CLI options as you normally would Usage: typer run [OPTIONS] Run the provided Typer app. Options: --name TEXT  [required] --help       Show this message and exit. // Then try completion with your program $ typer ./main.py run -- [ TAB ][ TAB ] // You get completion for CLI options --help  -- Show this message and exit. --name // And you can run it as if it was with Python directly $ typer ./main.py run --name Camila Hello Camila How shell completion works ¬∂ The way it works internally is that the shell/terminal will call your CLI program with some special environment variables (that hold the current CLI parameters , etc) and your CLI program will print some special values that the shell will use to present completion. All this is handled for you by Typer behind the scenes. But the main important point is that it is all based on values printed by your program that the shell reads. Breaking completion in a callback ¬∂ Let's say that when the callback is running, we want to show a message saying that it's validating the name: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def name_callback ( value : str ): print ( "Validating name" ) if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : Annotated [ str , typer . Option ( callback = name_callback )]): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def name_callback ( value : str ): print ( "Validating name" ) if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) And because the callback will be called when the shell calls your program asking for completion, that message "Validating name" will be printed and it will break completion. It will look something like: // Run it normally $ typer ./main.py run --name Camila // See the extra message "Validating name" Validating name Hello Camila $ typer ./main.py run -- [ TAB ][ TAB ] // Some weird broken error message ‚õîÔ∏è (eval) :1: command not found: Validating rutyper ./main.pyed Typer app. Fix completion - using the Context ¬∂ When you create a Typer application it uses Click underneath. And every Click application has a special object called a "Context" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . The "context" has some additional data about the current execution of your program: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def name_callback ( ctx : typer . Context , value : str ): if ctx . resilient_parsing : return print ( "Validating name" ) if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : Annotated [ str , typer . Option ( callback = name_callback )]): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def name_callback ( ctx : typer . Context , value : str ): if ctx . resilient_parsing : return print ( "Validating name" ) if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) The ctx.resilient_parsing will be True when handling completion, so you can just return without printing anything else. But it will be False when calling the program normally. So you can continue the execution of your previous code. That's all is needed to fix completion üöÄ Check it: $ typer ./main.py run -- [ TAB ][ TAB ] // Now it works correctly üéâ --help  -- Show this message and exit. --name // And you can call it normally $ typer ./main.py run --name Camila Validating name Hello Camila Using the CallbackParam object ¬∂ The same way you can access the typer.Context by declaring a function parameter with its value, you can declare another function parameter with type typer.CallbackParam to get the specific Click Parameter object. Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def name_callback ( ctx : typer . Context , param : typer . CallbackParam , value : str ): if ctx . resilient_parsing : return print ( f "Validating param: { param . name } " ) if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : Annotated [ str , typer . Option ( callback = name_callback )]): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def name_callback ( ctx : typer . Context , param : typer . CallbackParam , value : str ): if ctx . resilient_parsing : return print ( f "Validating param: { param . name } " ) if value != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) It's probably not very common, but you could do it if you need it. For example if you had a callback that could be used by several CLI parameters , that way the callback could know which parameter is each time. Check it: $ python main.py --name Camila Validating param: name Hello Camila Technical Details ¬∂ Because you get the relevant data in the callback function based on standard Python type annotations, you get type checks and autocompletion in your editor for free. And Typer will make sure you get the function parameters you want. You don't have to worry about their names, their order, etc. As it's based on standard Python types, it " just works ". ‚ú® Click's Parameter ¬∂ The typer.CallbackParam is actually just a sub-class of Click's Parameter , so you get all the right completion in your editor. Callback with type annotations ¬∂ You can get the typer.Context and the typer.CallbackParam simply by declaring a function parameter of each type. The order doesn't matter, the name of the function parameters doesn't matter. You could also get only the typer.CallbackParam and not the typer.Context , or vice versa, it will still work. value function parameter ¬∂ The value function parameter in the callback can also have any name (e.g. lastname ) and any type, but it should have the same type annotation as in the main function, because that's what it will receive. It's also possible to not declare its type. It will still work. And it's possible to not declare the value parameter at all, and, for example, only get the typer.Context . That will also work. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Required CLI Options - Typer Typer Required CLI Options Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Required CLI Options We said before that by default : CLI options are optional CLI arguments are required Well, that's how they work by default , and that's the convention in many CLI programs and systems. But if you really want, you can change that. To make a CLI option required, you can put typer.Option() inside of Annotated and leave the parameter without a default value. Let's make --lastname a required CLI option : Python 3.6+ import typer from typing_extensions import Annotated def main ( name : str , lastname : Annotated [ str , typer . Option ()]): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) The same way as with typer.Argument() , the old style of using the function parameter default value is also supported, in that case you would just not pass anything to the default parameter. Python 3.6+ non-Annotated import typer def main ( name : str , lastname : str = typer . Option ()): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Or you can explictily pass ... to typer.Option(default=...) : Python 3.6+ non-Annotated import typer def main ( name : str , lastname : str = typer . Option ( default =... )): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Info If you hadn't seen that ... before: it is a special single value, it is part of Python and is called "Ellipsis" . That will tell Typer that it's still a CLI option , but it doesn't have a default value, and it's required. Tip Again, prefer to use the Annotated version if possible. That way your code will mean the same in standard Python and in Typer . And test it: // Pass the NAME CLI argument $ python main.py Camila // We didn't pass the now required --lastname CLI option Usage: main.py [OPTIONS] NAME Try "main.py --help" for help. Error: Missing option '--lastname'. // Now update it to pass the required --lastname CLI option $ python main.py Camila --lastname Guti√©rrez Hello Camila Guti√©rrez // And if you check the help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --lastname TEXT       [required] --help                Show this message and exit. // It now tells you that --lastname is required üéâ Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Option Prompt - Typer Skip to content Typer CLI Option Prompt Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt CLI Option Prompt Table of contents Customize the prompt Confirmation prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Customize the prompt Confirmation prompt CLI Option Prompt It's also possible to, instead of just showing an error, ask for the missing value with prompt=True : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : str , lastname : Annotated [ str , typer . Option ( prompt = True )]): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = True )): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) And then your program will ask the user for it in the terminal: // Call it with the NAME CLI argument $ python main.py Camila // It asks for the missing CLI option --lastname # Lastname: $ Guti√©rrez Hello Camila Guti√©rrez Customize the prompt ¬∂ You can also set a custom prompt, passing the string that you want to use instead of just True : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : str , lastname : Annotated [ str , typer . Option ( prompt = "Please tell me your last name" )], ): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = "Please tell me your last name" ) ): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) And then your program will ask for it using with your custom prompt: // Call it with the NAME CLI argument $ python main.py Camila // It uses the custom prompt # Please tell me your last name: $ Guti√©rrez Hello Camila Guti√©rrez Confirmation prompt ¬∂ In some cases you could want to prompt for something and then ask the user to confirm it by typing it twice. You can do it passing the parameter confirmation_prompt=True . Let's say it's a CLI app to delete a project: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( project_name : Annotated [ str , typer . Option ( prompt = True , confirmation_prompt = True )] ): print ( f "Deleting project { project_name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( project_name : str = typer . Option ( ... , prompt = True , confirmation_prompt = True )): print ( f "Deleting project { project_name } " ) if __name__ == "__main__" : typer . run ( main ) And it will prompt the user for a value and then for the confirmation: $ python main.py // Your app will first prompt for the project name, and then for the confirmation # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // If the user doesn't type the same, receives an error and a new prompt $ python main.py # Project name: $ Old Project # Repeat for confirmation: $ New Spice Error: the two entered values do not match # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // Now it works üéâ Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Version CLI Option, is_eager - Typer Skip to content Typer Version CLI Option, is_eager Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Version CLI Option, is_eager Table of contents First version of --version Previous parameters and is_eager Fix with is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents First version of --version Previous parameters and is_eager Fix with is_eager Version CLI Option, is_eager You could use a callback to implement a --version CLI option . It would show the version of your CLI program and then it would terminate it. Even before any other CLI parameter is processed. First version of --version ¬∂ Let's see a first version of how it could look like: Python 3.6+ Python 3.6+ non-Annotated from typing import Optional import typer from typing_extensions import Annotated __version__ = "0.1.0" def version_callback ( value : bool ): if value : print ( f "Awesome CLI Version: { __version__ } " ) raise typer . Exit () def main ( name : Annotated [ str , typer . Option ()] = "World" , version : Annotated [ Optional [ bool ], typer . Option ( "--version" , callback = version_callback ) ] = None , ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import Optional import typer __version__ = "0.1.0" def version_callback ( value : bool ): if value : print ( f "Awesome CLI Version: { __version__ } " ) raise typer . Exit () def main ( name : str = typer . Option ( "World" ), version : Optional [ bool ] = typer . Option ( None , "--version" , callback = version_callback ), ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Notice that we don't have to get the typer.Context and check for ctx.resilient_parsing for completion to work, because we only print and modify the program when --version is passed, otherwise, nothing is printed or changed from the callback. If the --version CLI option is passed, we get a value True in the callback. Then we can print the version and raise typer.Exit() to make sure the program is terminated before anything else is executed. We also declare the explicit CLI option name --version , because we don't want an automatic --no-version , it would look awkward. Check it: $ python main.py --help // We get a --version, and don't get an awkward --no-version üéâ Usage: main.py [OPTIONS] Options: --version --name TEXT --help                Show this message and exit. // We can call it normally $ python main.py --name Camila Hello Camila // And we can get the version $ python main.py --version Awesome CLI Version: 0.1.0 // Because we exit in the callback, we don't get a "Hello World" message after the version üöÄ Previous parameters and is_eager ¬∂ But now let's say that the --name CLI option that we declared before --version is required, and it has a callback that could exit the program: Python 3.6+ Python 3.6+ non-Annotated from typing import Optional import typer from typing_extensions import Annotated __version__ = "0.1.0" def version_callback ( value : bool ): if value : print ( f "Awesome CLI Version: { __version__ } " ) raise typer . Exit () def name_callback ( name : str ): if name != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) def main ( name : Annotated [ str , typer . Option ( callback = name_callback )], version : Annotated [ Optional [ bool ], typer . Option ( "--version" , callback = version_callback ) ] = None , ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import Optional import typer __version__ = "0.1.0" def version_callback ( value : bool ): if value : print ( f "Awesome CLI Version: { __version__ } " ) raise typer . Exit () def name_callback ( name : str ): if name != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) def main ( name : str = typer . Option ( ... , callback = name_callback ), version : Optional [ bool ] = typer . Option ( None , "--version" , callback = version_callback ), ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Then our CLI program could not work as expected in some cases as it is right now , because if we use --version after --name then the callback for --name will be processed before and we can get its error: $ python main.py --name Rick --version Only Camila is allowed Aborted! Tip We don't have to check for ctx.resilient_parsing in the name_callback() for completion to work, because we are not using typer.echo() , instead we are raising a typer.BadParameter . Technical Details typer.BadParameter prints the error to "standard error", not to "standard output", and because the completion system only reads from "standard output", it won't break completion. Info If you need a refresher about what is "standard output" and "standard error" check the section in Printing and Colors: "Standard Output" and "Standard Error" . Fix with is_eager ¬∂ For those cases, we can mark a CLI parameter (a CLI option or CLI argument ) with is_eager=True . That will tell Typer (actually Click) that it should process this CLI parameter before the others: Python 3.6+ Python 3.6+ non-Annotated from typing import Optional import typer from typing_extensions import Annotated __version__ = "0.1.0" def version_callback ( value : bool ): if value : print ( f "Awesome CLI Version: { __version__ } " ) raise typer . Exit () def name_callback ( name : str ): if name != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return name def main ( name : Annotated [ str , typer . Option ( callback = name_callback )], version : Annotated [ Optional [ bool ], typer . Option ( "--version" , callback = version_callback , is_eager = True ), ] = None , ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import Optional import typer __version__ = "0.1.0" def version_callback ( value : bool ): if value : print ( f "Awesome CLI Version: { __version__ } " ) raise typer . Exit () def name_callback ( name : str ): if name != "Camila" : raise typer . BadParameter ( "Only Camila is allowed" ) return name def main ( name : str = typer . Option ( ... , callback = name_callback ), version : Optional [ bool ] = typer . Option ( None , "--version" , callback = version_callback , is_eager = True ), ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py --name Rick --version // Now we only get the version, and the name is not used Awesome CLI Version: 0.1.0 Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Option Name - Typer Skip to content Typer CLI Option Name Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Name Table of contents CLI option short names CLI option short names together CLI option short names with values Defining CLI option short names CLI option only short name CLI option short name and default CLI option short names together CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents CLI option short names CLI option short names together CLI option short names with values Defining CLI option short names CLI option only short name CLI option short name and default CLI option short names together CLI Option Name By default Typer will create a CLI option name from the function parameter. So, if you have a function with: def main ( user_name : Optional [ str ] = None ): pass or def main ( user_name : Annotated [ Optional [ str ], typer . Option ()] = None ): pass Typer will create a CLI option : --user-name But you can customize it if you want to. Let's say the function parameter name is user_name as above, but you want the CLI option to be just --name . You can pass the CLI option name that you want to have in the following positional argument passed to typer.Option() : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( user_name : Annotated [ str , typer . Option ( "--name" )]): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Here you are passing the string "--name" as the first positional argument to typer.Option() . Tip Prefer to use the Annotated version if possible. import typer def main ( user_name : str = typer . Option ( ... , "--name" )): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Here you are passing the string "--name" as the second positional argument to typer.Option() , as the first argument is ... to mark it as required. Info " Positional " means that it's not a function argument with a keyword name. For example show_default=True is a keyword argument. " show_default " is the keyword. But in "--name" there's no option_name="--name" or something similar, it's just the string value "--name" that goes in typer.Option() . That's a "positional argument" in a function. Check it: $ python main.py --help // Notice the --name instead of --user-name Usage: main.py [OPTIONS] Options: --name TEXT           [required] --help                Show this message and exit. // Try it $ python --name Camila Hello Camila CLI option short names ¬∂ A short name is a CLI option name with a single dash ( - ) instead of 2 ( -- ) and a single letter, like -n instead of --name . For example, the ls program has a CLI option named --size , and the same CLI option also has a short name -s : // With the long name --size $ ls ./myproject --size 12 first-steps.md   4 intro.md // With the short name -s $ ls ./myproject -s 12 first-steps.md   4 intro.md // Both CLI option names do the same CLI option short names together ¬∂ Short names have another feature, when they have a single letter, as in -s , you can put several of these CLI options together, with a single dash. For example, the ls program has these 2 CLI options (among others): --size : show the sizes of the listed files. --human : show a human-readable format, like 1MB instead of just 1024 . And these 2 CLI options have short versions too: --size : short version -s . --human : short version -h . So, you can put them together with -sh or -hs : // Call ls with long CLI options $ ls --size --human 12K first-steps.md   4.0K intro.md // Now with short versions $ ls -s -h 12K first-steps.md   4.0K intro.md // And with short versions together $ ls -sh 12K first-steps.md   4.0K intro.md // Order in short versions doesn't matter $ ls -hs 12K first-steps.md   4.0K intro.md // They all work the same üéâ CLI option short names with values ¬∂ When you use CLI options with short names, you can put them together if they are just boolean flags, like --size or --human . But if you have a CLI option --file with a short name -f that takes a value, if you put it with other short names for CLI options , you have to put it as the last letter, so that it can receive the value that comes right after. For example, let's say you are decompressing/extracting a file myproject.tar.gz with the program tar . You can pass these CLI option short names to tar : -x : means "e X tract", to decompress and extract the contents. -v : means " V erbose", to print on the screen what it is doing, so you can know that it's decompressing each file and can entertain yourself while you wait. -f : means " F ile", this one requires a value, the compressed file to extract (in our example, this is myproject.tar.gz ). So if you use all the short names together, this -f has to come last, to receive the value that comes next to it. For example: $ tar -xvf myproject.tar.gz myproject/ myproject/first-steps.md myproject/intro.md // But if you put the -f before $ tar -fxv myproject.tar.gz // You get an ugly error tar: You must specify one of the blah, blah, error, error Defining CLI option short names ¬∂ In Typer you can also define CLI option short names the same way you can customize the long names. YOu can pass positional arguments to typer.Option() to define the CLI option name(s). Tip Remember the positional function arguments are those that don't have a keyword. All the other function arguments/parameters you pass to typer.Option() like prompt=True and help="This option blah, blah" require the keyword. You can overwrite the CLI option name to use as in the previous example, but you can also declare extra alternatives, including short names. For example, extending the previous example, let's add a CLI option short name -n : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( user_name : Annotated [ str , typer . Option ( "--name" , "-n" )]): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( user_name : str = typer . Option ( ... , "--name" , "-n" )): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Here we are overwriting the CLI option name that by default would be --user-name , and we are defining it to be --name . And we are also declaring a CLI option short name of -n . Check it: // Check the help $ python main.py --help // Notice the two CLI option names -n and --name Usage: main.py [OPTIONS] Options: -n, --name TEXT       [required] --help                Show this message and exit. // Try the short version $ python main.py -n Camila Hello Camila CLI option only short name ¬∂ If you only declare a short name like -n then that will be the only CLI option name. And neither --name nor --user-name will be available. Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( user_name : Annotated [ str , typer . Option ( "-n" )]): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( user_name : str = typer . Option ( ... , "-n" )): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no --name nor --user-name, only -n Usage: main.py [OPTIONS] Options: -n TEXT               [required] --help                Show this message and exit. // Try it $ python main.py -n Camila Hello Camila CLI option short name and default ¬∂ Continuing with the example above, as Typer allows you to declare a CLI option as having only a short name, if you want to have the default long name plus a short name, you have to declare both explicitly: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( user_name : Annotated [ str , typer . Option ( "--user-name" , "-n" )]): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( user_name : str = typer . Option ( ... , "--user-name" , "-n" )): print ( f "Hello { user_name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py --help // Notice that we have the long version --user-name back // and we also have the short version -n Usage: main.py [OPTIONS] Options: -n, --user-name TEXT  [required] --help                Show this message and exit. // Try it $ python main.py --user-name Camila Hello Camila // And try the short version $ python main.py -n Camila CLI option short names together ¬∂ You can create multiple short names and use them together. You don't have to do anything special for it to work (apart from declaring those short versions): Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Option ( "--name" , "-n" )], formal : Annotated [ bool , typer . Option ( "--formal" , "-f" )] = False , ): if formal : print ( f "Good day Ms. { name } ." ) else : print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Option ( ... , "--name" , "-n" ), formal : bool = typer . Option ( False , "--formal" , "-f" ), ): if formal : print ( f "Good day Ms. { name } ." ) else : print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Notice that, again, we are declaring the long and short version of the CLI option names. Check it: $ python main.py --help // We now have short versions -n and -f // And also long versions --name and --formal Usage: main.py [OPTIONS] Options: -n, --name TEXT       [required] -f, --formal --help                Show this message and exit. // Try the short versions $ python main.py -n Camila -f Good day Ms. Camila. // And try the 2 short versions together // See how -n has to go last, to be able to get the value $ python main.py -fn Camila Good day Ms. Camila. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Options with Help - Typer Skip to content Typer CLI Options with Help Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help CLI Options with Help Table of contents CLI Options help panels Help with style using Rich Hide default from help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents CLI Options help panels Help with style using Rich Hide default from help CLI Options with Help You already saw how to add a help text for CLI arguments with the help parameter. Let's now do the same for CLI options : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : str , lastname : Annotated [ str , typer . Option ( help = "Last name of person to greet." )] = "" , formal : Annotated [ bool , typer . Option ( help = "Say hi formally." )] = False , ): """ Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. """ if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str , lastname : str = typer . Option ( "" , help = "Last name of person to greet." ), formal : bool = typer . Option ( False , help = "Say hi formally." ), ): """ Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. """ if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) The same way as with typer.Argument() , we can put typer.Option() inside of Annotated . We can then pass the help keyword parameter: lastname : Annotated [ str , typer . Option ( help = "this option does this and that" )] = "" ...to create the help for that CLI option . The same way as with typer.Argument() , Typer also supports the old style using the function parameter default value: lastname : str = typer . Option ( default = "" , help = "this option does this and that" ) Copy that example from above to a file main.py . Test it: $ python main.py --help Usage: main.py [OPTIONS] NAME Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. Arguments: NAME  [required] Options: --lastname TEXT         Last name of person to greet. [default: ] --formal / --no-formal  Say hi formally.  [default: False] --help                  Show this message and exit. // Now you have a help text for the --lastname and --formal CLI options üéâ CLI Options help panels ¬∂ The same as with CLI arguments , you can put the help for some CLI options in different panels to be shown with the --help option. If you have installed Rich as described in the docs for Printing and Colors , you can set the rich_help_panel parameter to the name of the panel you want for each CLI option : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : str , lastname : Annotated [ str , typer . Option ( help = "Last name of person to greet." )] = "" , formal : Annotated [ bool , typer . Option ( help = "Say hi formally." , rich_help_panel = "Customization and Utils" ), ] = False , debug : Annotated [ bool , typer . Option ( help = "Enable debugging." , rich_help_panel = "Customization and Utils" ), ] = False , ): """ Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. """ if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str , lastname : str = typer . Option ( "" , help = "Last name of person to greet." ), formal : bool = typer . Option ( False , help = "Say hi formally." , rich_help_panel = "Customization and Utils" ), debug : bool = typer . Option ( False , help = "Enable debugging." , rich_help_panel = "Customization and Utils" ), ): """ Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. """ if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Now, when you check the --help option, you will see a default panel named " Options " for the CLI options that don't have a custom rich_help_panel . And below you will see other panels for the CLI options that have a custom panel set in the rich_help_panel parameter: $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] NAME                                </b> <b>                                                                     </b> Say hi to NAME, optionally with a <font color="#A1EFE4"><b>--lastname</b></font>. If <font color="#6B9F98"><b>--formal</b></font><font color="#A5A5A1"> is used, say hi very formally.                          </font> <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    name      <font color="#F4BF75"><b>TEXT</b></font>  [default: None] <font color="#A6194C">[required]</font>                   ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--lastname</b></font>                  <font color="#F4BF75"><b>TEXT</b></font>  Last name of person to greet.   ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                      <font color="#F4BF75"><b>    </b></font>  Show this message and exit.     ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Customization and Utils ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--formal</b></font>    <font color="#AE81FF"><b>--no-formal</b></font>      Say hi formally.                     ‚îÇ <font color="#A5A5A1">‚îÇ                              [default: no-formal]                 ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--debug</b></font>     <font color="#AE81FF"><b>--no-debug</b></font>       Enable debugging.                    ‚îÇ <font color="#A5A5A1">‚îÇ                              [default: no-debug]                  ‚îÇ</font> <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Here we have a custom CLI options panel named " Customization and Utils ". Help with style using Rich ¬∂ In a future section you will see how to use custom markup in the help for CLI options when reading about Commands - Command Help . If you are in a hurry you can jump there, but otherwise, it would be better to continue reading here and following the tutorial in order. Hide default from help ¬∂ You can tell Typer to not show the default value in the help text with show_default=False : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( fullname : Annotated [ str , typer . Option ( show_default = False )] = "Wade Wilson" ): print ( f "Hello { fullname } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( fullname : str = typer . Option ( "Wade Wilson" , show_default = False )): print ( f "Hello { fullname } " ) if __name__ == "__main__" : typer . run ( main ) And it will no longer show the default value in the help text: $ python main.py Hello Wade Wilson // Show the help $ python main.py --help Usage: main.py [OPTIONS] Options: --fullname TEXT --help                Show this message and exit. // Notice there's no [default: Wade Wilson] üî• Technical Details In Click applications the default values are hidden by default. üôà In Typer these default values are shown by default. üëÄ Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Application Directory - Typer Skip to content Typer CLI Application Directory Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory CLI Application Directory Table of contents About Path Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents About Path CLI Application Directory You can get the application directory where you can, for example, save configuration files with typer.get_app_dir() : from pathlib import Path import typer APP_NAME = "my-super-cli-app" def main (): app_dir = typer . get_app_dir ( APP_NAME ) config_path : Path = Path ( app_dir ) / "config.json" if not config_path . is_file (): print ( "Config file doesn't exist yet" ) if __name__ == "__main__" : typer . run ( main ) It will give you a directory for storing configurations appropriate for your CLI program for the current user in each operating system. Check it: $ python main.py Config file doesn't exist yet About Path ¬∂ If you hadn't seen something like that: Path ( app_dir ) / "config.json" A Path object can be used with / and it will convert it to the separator for the current system ( / for Unix systems and \ for Windows). If the first element is a Path object the next ones (after the / ) can be str . And it will create a new Path object from that. If you want a quick guide on using Path() you can check this post on Real Python or this post by Trey Hunner . In the code above, we are also explicitly declaring config_path as having type Path to help the editor provide completion and type checks: config_path : Path = Path ( app_dir ) / "config.json" Otherwise it could think it's a sub-type (a PurePath ) and stop providing completion for some methods. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Using Click - Typer Skip to content Typer Using Click Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Using Click Table of contents A single app with both Click and Typer How Click works Click Command Click Group How Typer works Combine Click and Typer Including a Click app in a Typer app Including a Typer app in a Click app About Click decorators Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents A single app with both Click and Typer How Click works Click Command Click Group How Typer works Combine Click and Typer Including a Click app in a Typer app Including a Typer app in a Click app About Click decorators Using Click Warning This is a more advanced topic, if you are starting with Typer , feel free to skip it. It will be mostly useful for people that already work with Click and have questions around it. Typer is powered by Click . It does all the work underneath. Here is some more information related to using both together. A single app with both Click and Typer ¬∂ If you already have a Click application and want to migrate to Typer , or to add some Typer components, you can get a Click Command from your Typer application and then use Click directly. How Click works ¬∂ Before knowing how to combine Click and Typer , let's first check a little about how Click works. Click Command ¬∂ Any Click application has an object of class Command . That's, more or less, the most basic Click object. A Command can have its own CLI arguments and CLI options , and it has a function that it calls. For example, in this Click app: import click @click . command () @click . option ( "--count" , default = 1 , help = "Number of greetings." ) @click . option ( "--name" , prompt = "Your name" , help = "The person to greet." ) def hello ( count , name ): """Simple program that greets NAME for a total of COUNT times.""" for x in range ( count ): click . echo ( "Hello %s !" % name ) if __name__ == "__main__" : hello () The original hello variable is converted by Click from a function to a Command object. And the original hello function is used by that Command internally, but it is no longer named hello (as hello is now a Click Command ). Click Group ¬∂ Then Click also has a Group class, it inherits from Command . So, a Group object is also a Command . A Group can also have its own CLI arguments and CLI options . A Group can have subcommands of class Command or sub groups of class Group as well. And a Group can also have a function that it calls, right before calling the function for any specific subcommand. For example: import click @click . group () def cli (): pass @click . command () def initdb (): click . echo ( "Initialized the database" ) @click . command () def dropdb (): click . echo ( "Dropped the database" ) cli . add_command ( initdb ) cli . add_command ( dropdb ) if __name__ == "__main__" : cli () The cli variable is converted by Click from a function to a Group object. And the original cli function is used by that Group internally. Tip The original cli function would be the equivalent of a Typer Callback . Then the cli variable, that now is a Group object, is used to add sub-commands. How Typer works ¬∂ Typer doesn't modify the functions. You create an explicit variable of class typer.Typer and use it to register those functions. And then, when you call the app, Typer goes and creates a Click Command (or Group ), and then calls it. If your app only has one command, then when you call it, Typer creates a single Click Command object and calls it. But Typer creates a Click Group object if your app has any of: More than one command. A callback. Sub-Typer apps (sub commands). Tip If you want to learn more about this check the section One or Multiple Commands . Combine Click and Typer ¬∂ Typer uses an internal function typer.main.get_command() to generate a Click Command (or Group ) from a typer.Typer object. You can use it directly, and use the Click object with other Click applications. Including a Click app in a Typer app ¬∂ For example, you could have a Typer app, generate a Click Group from it, and then include other Click apps in it: import click import typer app = typer . Typer () @app . command () def top (): """ Top level command, form Typer """ print ( "The Typer app is at the top level" ) @app . callback () def callback (): """ Typer app, including Click subapp """ @click . command () @click . option ( "--name" , prompt = "Your name" , help = "The person to greet." ) def hello ( name ): """Simple program that greets NAME for a total of COUNT times.""" click . echo ( "Hello %s !" % name ) typer_click_object = typer . main . get_command ( app ) typer_click_object . add_command ( hello , "hello" ) if __name__ == "__main__" : typer_click_object () Notice that we add a callback that does nothing (only document the CLI program), to make sure Typer creates a Click Group . That way we can add sub-commands to that Click Group . Then we generate a Click object from our typer.Typer app ( typer_click_object ), and then we can include another Click object ( hello ) in this Click Group . And that way, our Typer app will have a subcommand top built with Typer, and a subcommand hello built with Click. Check it: $ python main.py // Notice we have both subcommands, top and hello Usage: main.py [OPTIONS] COMMAND [ARGS]... Error: Missing command. // Call the Typer part $ python main.py top The Typer app is at the top level // Call the Click part $ python main.py hello --name Camila Hello Camila! Including a Typer app in a Click app ¬∂ The same way, you can do the contrary and include a Typer sub app in a bigger Click app: import click import typer @click . group () def cli (): pass @cli . command () def initdb (): click . echo ( "Initialized the database" ) @cli . command () def dropdb (): click . echo ( "Dropped the database" ) app = typer . Typer () @app . command () def sub (): """ A single-command Typer sub app """ print ( "Typer is now below Click, the Click app is the top level" ) typer_click_object = typer . main . get_command ( app ) cli . add_command ( typer_click_object , "sub" ) if __name__ == "__main__" : cli () Notice that we don't have to add a callback or more commands, we can just create a Typer app that generates a single Click Command , as we don't need to include anything under the Typer app. Then we generate a Click object from our typer.Typer app ( typer_click_object ), and then we use the Click cli to include our Click object from our Typer app. In this case, the original Click app includes the Typer app. And then we call the original Click app, not the Typer app. Check it: $ python main.py // We get our Typer app down there in the sub command Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --help  Show this message and exit. Commands: dropdb initdb sub     A single-command Typer sub app // Use the Click part $ python main.py initdb Initialized the database // And use the Typer part $ python main.py sub Typer is now below Click, the Click app is the top level About Click decorators ¬∂ Typer apps don't work with Click decorators directly. This is because Typer doesn't modify functions to add metadata or to convert them to another object like Click does. So, things like @click.pass_context won't work. Most of the functionality provided by decorators in Click has an alternative way of doing it in Typer . For example, to access the context, you can just declare a function parameter of type typer.Context . Tip You can read more about using the context in the docs: Commands: Using the Context But if you need to use something based on Click decorators, you can always generate a Click object using the methods described above, and use it as you would normally use Click. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Launching Applications - Typer Skip to content Typer Launching Applications Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Launching Applications Table of contents Locating a file Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Locating a file Launching Applications You can launch applications from your CLI program with typer.launch() . It will launch the appropriate application depending on the URL or file type you pass it: import typer def main (): print ( "Opening Typer's docs" ) typer . launch ( "https://typer.tiangolo.com" ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py Opening Typer docs // Opens browser with Typer's docs Locating a file ¬∂ You can also make the operating system open the file browser indicating where a file is located with locate=True : from pathlib import Path import typer APP_NAME = "my-super-cli-app" def main (): app_dir = typer . get_app_dir ( APP_NAME ) app_dir_path = Path ( app_dir ) app_dir_path . mkdir ( parents = True , exist_ok = True ) config_path : Path = Path ( app_dir ) / "config.json" if not config_path . is_file (): config_path . write_text ( '{"version": "1.0.0"}' ) config_file_str = str ( config_path ) print ( "Opening config directory" ) typer . launch ( config_file_str , locate = True ) if __name__ == "__main__" : typer . run ( main ) Tip The rest of the code in this example is just making sure the app directory exists and creating the config file. But the most important part is the typer.launch(config_file_str, locate=True) with the argument locate=True . Check it: $ python main.py Opening config directory // Opens a file browser indicating where the config file is located Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

SubCommands - Command Groups - Intro - Typer Typer SubCommands - Command Groups - Intro Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes SubCommands - Command Groups - Intro You read before how to create a program with Commands . Now we'll see how to create a CLI program with commands that have their own subcommands. Also known as command groups. For example, the CLI program git has a command remote . But git remote , in turn, has its own subcommands, like add : // git remote alone shows the current remote repositories $ git remote origin // Use -v to make it verbose and show more info $ git remote -v origin  git@github.com:yourusername/typer.git (fetch) origin  git@github.com:yourusername/typer.git (push) // git remote add takes 2 CLI arguments, a name and URL $ git remote add upstream https://github.com/tiangolo/typer.git // Doesn't output anything, but now you have another remote repository called upstream // Now check again $ git remote -v origin  git@github.com:yourusername/typer.git (fetch) origin  git@github.com:yourusername/typer.git (push) upstream        https://github.com/tiangolo/typer.git (fetch) upstream        https://github.com/tiangolo/typer.git (push) In the next sections we'll see how to create subcommands like these. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Nested SubCommands - Typer Skip to content Typer Nested SubCommands Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Nested SubCommands Table of contents A CLI app for reigns A CLI app for towns Manage the land in a CLI app Deeply nested subcommands Review the files Recap Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents A CLI app for reigns A CLI app for towns Manage the land in a CLI app Deeply nested subcommands Review the files Recap Nested SubCommands We'll now see how these same ideas can be extended for deeply nested commands. Let's imagine that the same CLI program from the previous examples now needs to handle lands . But a land could be a reign or town . And each of those could have their own commands, like create and delete . A CLI app for reigns ¬∂ Let's start with a file reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): print ( f "Conquering reign: { name } " ) @app . command () def destroy ( name : str ): print ( f "Destroying reign: { name } " ) if __name__ == "__main__" : app () This is already a simple CLI program to manage reigns: // Check the help $ python reigns.py --help Usage: reigns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: conquer destroy // Try it $ python reigns.py conquer Cintra Conquering reign: Cintra $ python reigns.py destroy Mordor Destroying reign: Mordor A CLI app for towns ¬∂ And now the equivalent for managing towns in towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): print ( f "Founding town: { name } " ) @app . command () def burn ( name : str ): print ( f "Burning town: { name } " ) if __name__ == "__main__" : app () With it, you can manage towns: // Check the help $ python towns.py --help Usage: towns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: burn found // Try it $ python towns.py found "New Asgard" Founding town: New Asgard $ python towns.py burn Vizima Burning town: Vizima Manage the land in a CLI app ¬∂ Now let's put the reigns and towns together in the same CLI program in lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = "reigns" ) app . add_typer ( towns . app , name = "towns" ) if __name__ == "__main__" : app () And now we have a single CLI program with a command (or command group) reigns that has its own commands. And another command towns with its own subcommands. Check it: // Check the help $ python lands.py --help Usage: lands.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: reigns towns // We still have the help for reigns $ python lands.py reigns --help Usage: lands.py reigns [OPTIONS] COMMAND [ARGS]... Options: --help  Show this message and exit. Commands: conquer destroy // And the help for towns $ python lands.py towns --help Usage: lands.py towns [OPTIONS] COMMAND [ARGS]... Options: --help  Show this message and exit. Commands: burn found Now try it, manage the lands through the CLI: // Try the reigns command $ python lands.py reigns conquer Gondor Conquering reign: Gondor $ python lands.py reigns destroy Nilfgaard Destroying reign: Nilfgaard // Try the towns command $ python lands.py towns found Springfield Founding town: Springfield $ python lands.py towns burn Atlantis Burning town: Atlantis Deeply nested subcommands ¬∂ Now let's say that all these commands in the lands.py CLI program should be part of the previous CLI program we built in the first example. We want our CLI program to have these commands/command groups: users : create delete items : create delete sell lands : reigns : conquer destroy towns : found burn This already is a quite deeply nested "tree" of commands/command groups. But to achieve that, we just have to add the lands Typer app to the same main.py file we already had: import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = "users" ) app . add_typer ( items . app , name = "items" ) app . add_typer ( lands . app , name = "lands" ) if __name__ == "__main__" : app () And now we have everything in a single CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: items lands users // Try some users commands $ python main.py users create Camila Creating user: Camila // Now try some items commands $ python main.py items create Sword Creating item: Sword // And now some lands commands for reigns $ python main.py lands reigns conquer Gondor Conquering reign: Gondor // And for towns $ python main.py lands towns found Cartagena Founding town: Cartagena Review the files ¬∂ Here are all the files if you want to review/copy them: reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): print ( f "Conquering reign: { name } " ) @app . command () def destroy ( name : str ): print ( f "Destroying reign: { name } " ) if __name__ == "__main__" : app () towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): print ( f "Founding town: { name } " ) @app . command () def burn ( name : str ): print ( f "Burning town: { name } " ) if __name__ == "__main__" : app () lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = "reigns" ) app . add_typer ( towns . app , name = "towns" ) if __name__ == "__main__" : app () users.py : import typer app = typer . Typer () @app . command () def create ( user_name : str ): print ( f "Creating user: { user_name } " ) @app . command () def delete ( user_name : str ): print ( f "Deleting user: { user_name } " ) if __name__ == "__main__" : app () items.py : import typer app = typer . Typer () @app . command () def create ( item : str ): print ( f "Creating item: { item } " ) @app . command () def delete ( item : str ): print ( f "Deleting item: { item } " ) @app . command () def sell ( item : str ): print ( f "Selling item: { item } " ) if __name__ == "__main__" : app () main.py : import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = "users" ) app . add_typer ( items . app , name = "items" ) app . add_typer ( lands . app , name = "lands" ) if __name__ == "__main__" : app () Tip All these files have an if __name__ == "__main__" block just to demonstrate how each of them can also be an independent CLI app . But for your final application, only main.py would need it. Recap ¬∂ That's it, you can just add Typer applications one inside another as much as you want and create complex CLI programs while writing simple code. You can probably achieve a simpler CLI program design that's easier to use than the example here. But if your requirements are complex, Typer helps you build your CLI app easily. Tip Auto completion helps a lot, specially with complex programs. Check the docs about adding auto completion to your CLI apps . Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Add Typer - Typer Skip to content Typer Add Typer Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer Add Typer Table of contents Manage items Manage users Put them together Recap SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Manage items Manage users Put them together Recap Add Typer We'll start with the core idea. To add a typer.Typer() app inside of another. Manage items ¬∂ Let's imagine that you are creating a CLI program to manage items in some distant land. It could be in an items.py file with this: import typer app = typer . Typer () @app . command () def create ( item : str ): print ( f "Creating item: { item } " ) @app . command () def delete ( item : str ): print ( f "Deleting item: { item } " ) @app . command () def sell ( item : str ): print ( f "Selling item: { item } " ) if __name__ == "__main__" : app () And you would use it like: $ python items.py create Wand Creating item: Wand Manage users ¬∂ But then you realize that you also have to manage users from your CLI app . It could be a file users.py with something like: import typer app = typer . Typer () @app . command () def create ( user_name : str ): print ( f "Creating user: { user_name } " ) @app . command () def delete ( user_name : str ): print ( f "Deleting user: { user_name } " ) if __name__ == "__main__" : app () And you would use it like: $ python users.py create Camila Creating user: Camila Put them together ¬∂ Both parts are similar. In fact, items.py and users.py both have commands create and delete . But we need them to be part of the same CLI program . In this case, as with git remote , we can put them together as subcommands in another typer.Typer() CLI program . Now create a main.py with: import typer import items import users app = typer . Typer () app . add_typer ( users . app , name = "users" ) app . add_typer ( items . app , name = "items" ) if __name__ == "__main__" : app () Here's what we do in main.py : Import the other Python modules (the files users.py and items.py ). Create the main typer.Typer() application. Use app.add_typer() to include the app from items.py and users.py , each of those 2 was also created with typer.Typer() . Define a name with the command that will be used for each of these "sub-Typers" to group their own commands. And now your CLI program has 2 commands: users : with all of the commands (subcommands) in the app from users.py . items with all the commands (subcommands) in the app from items.py . Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: items users Now you have a CLI program with commands items and users , and they in turn have their own commands (subcommands). Let's check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help  Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase Tip Notice that we are still calling $ python main.py but now we are using the command items . And now check the command users , with all its subcommands: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help  Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila Recap ¬∂ That's the core idea. You can just create typer.Typer() apps and add them inside one another. And you can do that with any levels of commands that you want. Do you need sub-sub-sub-subcommands? Go ahead, create all the typer.Typer() s you need and put them together with app.add_typer() . In the next sections we'll update this with more features, but you already have the core idea. This way, in the same spirit of Click, Typer applications are composable, each typer.Typer() can be a CLI app by itself, but it can also be added as a command group to another Typer app. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

SubCommands in a Single File - Typer Skip to content Typer SubCommands in a Single File Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File SubCommands in a Single File Table of contents Apps at the top Function names Command name Check it Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Apps at the top Function names Command name Check it SubCommands in a Single File In some cases, it's possible that your application code needs to live on a single file. You can still use the same ideas: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = "items" ) users_app = typer . Typer () app . add_typer ( users_app , name = "users" ) @items_app . command ( "create" ) def items_create ( item : str ): print ( f "Creating item: { item } " ) @items_app . command ( "delete" ) def items_delete ( item : str ): print ( f "Deleting item: { item } " ) @items_app . command ( "sell" ) def items_sell ( item : str ): print ( f "Selling item: { item } " ) @users_app . command ( "create" ) def users_create ( user_name : str ): print ( f "Creating user: { user_name } " ) @users_app . command ( "delete" ) def users_delete ( user_name : str ): print ( f "Deleting user: { user_name } " ) if __name__ == "__main__" : app () There are several things to notice here... Apps at the top ¬∂ First, you can create typer.Typer() objects and add them to another one at the top. It doesn't have to be done after creating the subcommands: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = "items" ) users_app = typer . Typer () app . add_typer ( users_app , name = "users" ) @items_app . command ( "create" ) def items_create ( item : str ): print ( f "Creating item: { item } " ) @items_app . command ( "delete" ) def items_delete ( item : str ): print ( f "Deleting item: { item } " ) @items_app . command ( "sell" ) def items_sell ( item : str ): print ( f "Selling item: { item } " ) @users_app . command ( "create" ) def users_create ( user_name : str ): print ( f "Creating user: { user_name } " ) @users_app . command ( "delete" ) def users_delete ( user_name : str ): print ( f "Deleting user: { user_name } " ) if __name__ == "__main__" : app () You can add the commands (subcommands) to each typer.Typer() app later and it will still work. Function names ¬∂ As you now have subcommands like create for users and for items , you can no longer call the functions with just the name, like def create() , because they would overwrite each other. So we use longer names: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = "items" ) users_app = typer . Typer () app . add_typer ( users_app , name = "users" ) @items_app . command ( "create" ) def items_create ( item : str ): print ( f "Creating item: { item } " ) @items_app . command ( "delete" ) def items_delete ( item : str ): print ( f "Deleting item: { item } " ) @items_app . command ( "sell" ) def items_sell ( item : str ): print ( f "Selling item: { item } " ) @users_app . command ( "create" ) def users_create ( user_name : str ): print ( f "Creating user: { user_name } " ) @users_app . command ( "delete" ) def users_delete ( user_name : str ): print ( f "Deleting user: { user_name } " ) if __name__ == "__main__" : app () Command name ¬∂ We are naming the functions with longer names so that they don't overwrite each other. But we still want the subcommands to be create , delete , etc. To call them like: // We want this ‚úîÔ∏è $ python main.py items create instead of: // We don't want this ‚õîÔ∏è $ python main.py items items-create So we pass the name we want to use for each subcommand as the function argument to the decorator: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = "items" ) users_app = typer . Typer () app . add_typer ( users_app , name = "users" ) @items_app . command ( "create" ) def items_create ( item : str ): print ( f "Creating item: { item } " ) @items_app . command ( "delete" ) def items_delete ( item : str ): print ( f "Deleting item: { item } " ) @items_app . command ( "sell" ) def items_sell ( item : str ): print ( f "Selling item: { item } " ) @users_app . command ( "create" ) def users_create ( user_name : str ): print ( f "Creating user: { user_name } " ) @users_app . command ( "delete" ) def users_delete ( user_name : str ): print ( f "Deleting user: { user_name } " ) if __name__ == "__main__" : app () Check it ¬∂ It still works the same: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: items users Check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help  Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase And the same for the users command: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help  Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

SubCommand Name and Help - Typer Skip to content Typer SubCommand Name and Help Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help SubCommand Name and Help Table of contents Add a help text Inferring name and help from callback Inferring a command's name and help Inferring name and help from @app.callback() Name and help from callback parameter in typer.Typer() Override a callback set in typer.Typer() with @app.callback() Infer name and help from callback in app.add_typer() Enough inferring Set the name and help Name and help in typer.Typer() Name and help in @app.callback() Name and help in app.add_typer() Recap Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Add a help text Inferring name and help from callback Inferring a command's name and help Inferring name and help from @app.callback() Name and help from callback parameter in typer.Typer() Override a callback set in typer.Typer() with @app.callback() Infer name and help from callback in app.add_typer() Enough inferring Set the name and help Name and help in typer.Typer() Name and help in @app.callback() Name and help in app.add_typer() Recap SubCommand Name and Help When adding a Typer app to another we have seen how to set the name to use for the command. For example to set the command to users : app . add_typer ( users . app , name = "users" ) Add a help text ¬∂ We can also set the help while adding a Typer: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = "users" , help = "Manage users in the app." ) @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () And then we get that help text for that command in the CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: users  Manage users in the app. // Check the help for the users command $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help  Show this message and exit. Commands: create We can set the name and help in several places, each one taking precedence over the other, overriding the previous value. Let's see those locations. Tip There are other attributes that can be set in that same way in the same places we'll see next. But those are documented later in another section. Inferring name and help from callback ¬∂ Inferring a command's name and help ¬∂ When you create a command with @app.command() , by default, it generates the name from the function name. And by default, the help text is extracted from the function's docstring. For example: @app . command () def create ( item : str ): """ Create an item. """ typer . echo ( f "Creating item: { item } " ) ...will create a command create with a help text of Create an item . Inferring name and help from @app.callback() ¬∂ The same way, if you define a callback in a typer.Typer() , the help text is extracted from the callback function's docstring. And if that Typer app is added to another Typer app, the default name of the command is generated from the name of the callback function. Here's an example: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app ) @users_app . callback () def users (): """ Manage users in the app. """ @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Notice that now we added the sub-Typer without specifying a name nor a help . They are now inferred from the callback function. The command name will be the same callback function's name: users . And the help text for that users command will be the callback function's docstring: Manage users in the app. . Check it: // Check the main help $ python main.py --help // Notice the command name "users" and the help text "Manage users in the app." Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: users  Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: "Manage users in the app." Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help  Show this message and exit. Commands: create Name and help from callback parameter in typer.Typer() ¬∂ If you pass a callback parameter while creating a typer.Typer(callback=some_function) it will be used to infer the name and help text. This has the lowest priority, we'll see later what has a higher priority and can override it. Check the code: import typer app = typer . Typer () def users (): """ Manage users in the app. """ users_app = typer . Typer ( callback = users ) app . add_typer ( users_app ) @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () This achieves exactly the same as the previous example. Check it: // Check the main help $ python main.py --help // Notice the command name "users" and the help text "Manage users in the app." Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: users  Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: "Manage users in the app." Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help  Show this message and exit. Commands: create Override a callback set in typer.Typer() with @app.callback() ¬∂ The same as with normal Typer apps, if you pass a callback to typer.Typer(callback=some_function) and then override it with @app.callback() , the name and help text will be inferred from the new callback: import typer app = typer . Typer () def old_callback (): """ Old callback help. """ users_app = typer . Typer ( callback = old_callback ) app . add_typer ( users_app ) @users_app . callback () def users (): """ Manage users in the app. """ @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Now the name of the command will be users instead of old-callback , and the help text will be Manage users in the app. instead of Old callback help. . Check it: // Check the main help $ python main.py --help // Notice the command name "users" and the help text "Manage users in the app." Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: users  Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: "Manage users in the app." Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help  Show this message and exit. Commands: create Infer name and help from callback in app.add_typer() ¬∂ If you override the callback in app.add_typer() when including a sub-app, the name and help will be inferred from this callback function. This takes precedence over inferring the name and help from a callback set in @sub_app.callback() and typer.Typer(callback=sub_app_callback) . Check the code: import typer app = typer . Typer () def old_callback (): """ Old callback help. """ users_app = typer . Typer ( callback = old_callback ) def new_users (): """ I have the highland! Create some users. """ app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): """ Manage users in the app. """ @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Now the command will be new-users instead of users . And the help text will be I have the highland! Create some users. instead of the previous ones. Check it: // Check the main help $ python main.py --help // Check the command new-users and its help text Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: new-users  I have the highland! Create some users. // Now check the help for the new-users command $ python main.py new-users --help // Notice the help text Usage: main.py new-users [OPTIONS] COMMAND [ARGS]... I have the highland! Create some users. Options: --help  Show this message and exit. Commands: create Enough inferring ¬∂ So, when inferring a name and help text, the precedence order from lowest priority to highest is: sub_app = typer.Typer(callback=some_function) @sub_app.callback() app.add_typer(sub_app, callback=new_function) That's for inferring the name and help text from functions. But if you set the name and help text explicitly, that has a higher priority than these. Set the name and help ¬∂ Let's now see the places where you can set the command name and help text, from lowest priority to highest. Tip Setting the name and help text explicitly always has a higher precedence than inferring from a callback function. Name and help in typer.Typer() ¬∂ You could have all the callbacks and overrides we defined before, but the name and help text was inferred from the function name and docstring. If you set it explicitly, that takes precedence over inferring. You can set it when creating a new typer.Typer() : import typer app = typer . Typer () def old_callback (): """ Old callback help. """ users_app = typer . Typer ( callback = old_callback , name = "exp-users" , help = "Explicit help." ) def new_users (): """ I have the highland! Create some users. """ app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): """ Manage users in the app. """ @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Info The rest of the callbacks and overrides are there only to show you that they don't affect the name and help text when you set it explicitly. We set an explicit name exp-users , and an explicit help Explicit help. . So that will take precedence now. Check it: // Check the main help $ python main.py --help // Notice the command name is exp-users and the help text is "Explicit help." Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: exp-users  Explicit help. // Check the help for the exp-users command $ python main.py exp-users --help // Notice the main help text Usage: main.py exp-users [OPTIONS] COMMAND [ARGS]... Explicit help. Options: --help  Show this message and exit. Commands: create Name and help in @app.callback() ¬∂ Any parameter that you use when creating a typer.Typer() app can be overridden in the parameters of @app.callback() . Continuing with the previous example, we now override the values in @user_app.callback() : import typer app = typer . Typer () def old_callback (): """ Old callback help. """ users_app = typer . Typer ( callback = old_callback , name = "exp-users" , help = "Explicit help." ) def new_users (): """ I have the highland! Create some users. """ app . add_typer ( users_app , callback = new_users ) @users_app . callback ( "call-users" , help = "Help from callback for users." ) def users (): """ Manage users in the app. """ @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () And now the command name will be call-users and the help text will be Help from callback for users. . Check it: // Check the help $ python main.py --help // The command name now is call-users and the help text is "Help from callback for users.". Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: call-users  Help from callback for users. // Check the call-users command help $ python main.py call-users --help // Notice the main help text Usage: main.py call-users [OPTIONS] COMMAND [ARGS]... Help from callback for users. Options: --help  Show this message and exit. Commands: create Name and help in app.add_typer() ¬∂ And finally, with the highest priority, you can override all that by explicitly setting the name and help in app.add_typer() , just like we did on the first example above: import typer app = typer . Typer () def old_callback (): """ Old callback help. """ users_app = typer . Typer ( callback = old_callback , name = "exp-users" , help = "Explicit help." ) def new_users (): """ I have the highland! Create some users. """ app . add_typer ( users_app , callback = new_users , name = "cake-sith-users" , help = "Unlimited powder! Eh, users." , ) @users_app . callback ( "call-users" , help = "Help from callback for users." ) def users (): """ Manage users in the app. """ @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () And now, with the highest priorities of them all, the command name will now be cake-sith-users and the help text will be Unlimited powder! Eh, users. . Check it: // Check the help $ python main.py --help // Notice the command name cake-sith-users and the new help text "Unlimited powder! Eh, users." Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: cake-sith-users  Unlimited powder! Eh, users. // And check the help for the command cake-sith-users $ python main.py cake-sith-users --help // Notice the main help text Usage: main.py cake-sith-users [OPTIONS] COMMAND [ARGS]... Unlimited powder! Eh, users. Options: --help  Show this message and exit. Commands: create Recap ¬∂ The precedence to generate a command's name and help, from lowest priority to highest, is: Implicitly inferred from sub_app = typer.Typer(callback=some_function) Implicitly inferred from the callback function under @sub_app.callback() Implicitly inferred from app.add_typer(sub_app, callback=some_function) Explicitly set on sub_app = typer.Typer(name="some-name", help="Some help.") Explicitly set on @sub_app.callback("some-name", help="Some help.") Explicitly set on app.add_typer(sub_app, name="some-name", help="Some help.") So, app.add_typer(sub_app, name="some-name", help="Some help.") always wins. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Sub-Typer Callback Override - Typer Skip to content Typer Sub-Typer Callback Override Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override Sub-Typer Callback Override Table of contents Add a callback on creation Overriding the callback on creation Overriding the callback when adding a sub-Typer SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Add a callback on creation Overriding the callback on creation Overriding the callback when adding a sub-Typer Sub-Typer Callback Override When creating a Typer app you can define a callback function, it always executes and defines the CLI arguments and CLI options that go before a command. When adding a Typer app inside of another, the sub-Typer can also have its own callback. It can handle any CLI parameters that go before its own commands and execute any extra code: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = "users" ) @users_app . callback () def users_callback (): print ( "Running a users command" ) @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () In this case it doesn't define any CLI parameters , it just writes a message. Check it: $ python main.py users create Camila // Notice the first message is not created by the command function but by the callback Running a users command Creating user: Camila Add a callback on creation ¬∂ It's also possible to add a callback when creating the typer.Typer() app that will be added to another Typer app: import typer app = typer . Typer () def users_callback (): print ( "Running a users command" ) users_app = typer . Typer ( callback = users_callback ) app . add_typer ( users_app , name = "users" ) @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () This achieves exactly the same as above, it's just another place to add the callback. Check it: $ python main.py users create Camila Running a users command Creating user: Camila Overriding the callback on creation ¬∂ If a callback was added when creating the typer.Typer() app, it's possible to override it with a new one using @app.callback() . This is the same information you saw on the section about Commands - Typer Callback , and it applies the same for sub-Typer apps: import typer app = typer . Typer () def default_callback (): print ( "Running a users command" ) users_app = typer . Typer ( callback = default_callback ) app . add_typer ( users_app , name = "users" ) @users_app . callback () def user_callback (): print ( "Callback override, running users command" ) @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Here we had defined a callback when creating the typer.Typer() sub-app, but then we override it with a new callback with the function user_callback() . As @app.callback() takes precedence over typer.Typer(callback=some_function) , now our CLI app will use this new callback. Check it: $ python main.py users create Camila // Notice the message from the new callback Callback override, running users command Creating user: Camila Overriding the callback when adding a sub-Typer ¬∂ Lastly, you can override the callback defined anywhere else when adding a sub-Typer with app.add_typer() using the callback parameter. This has the highest priority: import typer app = typer . Typer () def default_callback (): print ( "Running a users command" ) users_app = typer . Typer ( callback = default_callback ) def callback_for_add_typer (): print ( "I have the high land! Running users command" ) app . add_typer ( users_app , name = "users" , callback = callback_for_add_typer ) @users_app . callback () def user_callback (): print ( "Callback override, running users command" ) @users_app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Notice that the precedence goes to app.add_typer() and is not affected by the order of execution. There's another callback defined below, but the one from app.add_typer() wins. Now when you use the CLI program it will use the new callback function callback_for_add_typer() . Check it: $ python users create Camila // Notice the message from the callback added in add_typer() I have the high land! Running users command Creating user: Camila Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Parameter Types Intro - Typer Skip to content Typer CLI Parameter Types Intro Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro CLI Parameter Types Intro Table of contents Data conversion Watch next Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Data conversion Watch next CLI Parameter Types Intro You can use several data types for the CLI options and CLI arguments , and you can add data validation requirements too. Data conversion ¬∂ When you declare a CLI parameter with some type Typer will convert the data received in the command line to that data type. For example: import typer def main ( name : str , age : int = 20 , height_meters : float = 1.89 , female : bool = True ): print ( f "NAME is { name } , of type: { type ( name ) } " ) print ( f "--age is { age } , of type: { type ( age ) } " ) print ( f "--height-meters is { height_meters } , of type: { type ( height_meters ) } " ) print ( f "--female is { female } , of type: { type ( female ) } " ) if __name__ == "__main__" : typer . run ( main ) In this example, the value received for the CLI argument NAME will be treated as str . The value for the CLI option --age will be converted to an int and --height-meters will be converted to a float . And as female is a bool CLI option , Typer will convert it to a "flag" --female and the counterpart --no-female . And here's how it looks like: $ python main.py --help // Notice how --age is an INTEGER and --height-meters is a FLOAT Usage: main.py [OPTIONS] NAME Arguments: NAME  [required] Options: --age INTEGER           [default: 20] --height-meters FLOAT   [default: 1.89] --female / --no-female  [default: True] --help                  Show this message and exit. // Call it with CLI parameters $ python main.py Camila --age 15 --height-meters 1 .70 --female // All the data has the correct Python type NAME is Camila, of type: class 'str' --age is 15, of type: class 'int' --height-meters is 1.7, of type: class 'float' --female is True, of type: class 'bool' // And if you pass an incorrect type $ python main.py Camila --age 15 .3 Usage: main.py [OPTIONS] NAME Try "main.py --help" for help. Error: Invalid value for '--age': 15.3 is not a valid integer // Because 15.3 is not an INTEGER (it's a float) Watch next ¬∂ See more about specific types and validations in the next sections... Technical Details All the types you will see in the next sections are handled underneath by Click's Parameter Types . Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Custom Types - Typer Skip to content Typer Custom Types Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types Custom Types Table of contents Type Parser Click Custom Type SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Type Parser Click Custom Type Custom Types You can easily use your own custom types in your Typer applications. The way to do it is by providing a way to parse input into your own types. There are two ways to achieve this: Adding a type parser Expanding Click's custom types Type Parser ¬∂ typer.Argument and typer.Option can create custom parameter types with a parser callable . Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated class CustomClass : def __init__ ( self , value : str ): self . value = value def __str__ ( self ): return f "<CustomClass: value= { self . value } >" def parse_custom_class ( value : str ): return CustomClass ( value * 2 ) def main ( custom_arg : Annotated [ CustomClass , typer . Argument ( parser = parse_custom_class )], custom_opt : Annotated [ CustomClass , typer . Option ( parser = parse_custom_class )] = "Foo" , ): print ( f "custom_arg is { custom_arg } " ) print ( f "--custom-opt is { custom_opt } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer class CustomClass : def __init__ ( self , value : str ): self . value = value def __str__ ( self ): return f "<CustomClass: value= { self . value } >" def parse_custom_class ( value : str ): return CustomClass ( value * 2 ) def main ( custom_arg : CustomClass = typer . Argument ( parser = parse_custom_class ), custom_opt : CustomClass = typer . Option ( "Y" , parser = parse_custom_class ), ): print ( f "custom_arg is { custom_arg } " ) print ( f "--custom-opt is { custom_opt } " ) if __name__ == "__main__" : typer . run ( main ) The function (or callable) that you pass to the parameter parser will receive the input value as a string and should return the parsed value with your own custom type. Click Custom Type ¬∂ If you already have a Click Custom Type , you can use it in typer.Argument() and typer.Option() with the click_type parameter. Python 3.6+ Python 3.6+ non-Annotated import click import typer from typing_extensions import Annotated class CustomClass : def __init__ ( self , value : str ): self . value = value def __repr__ ( self ): return f "<CustomClass: value= { self . value } >" class CustomClassParser ( click . ParamType ): name = "CustomClass" def convert ( self , value , param , ctx ): return CustomClass ( value * 3 ) def main ( custom_arg : Annotated [ CustomClass , typer . Argument ( click_type = CustomClassParser ())], custom_opt : Annotated [ CustomClass , typer . Option ( click_type = CustomClassParser ()) ] = "Foo" , ): print ( f "custom_arg is { custom_arg } " ) print ( f "--custom-opt is { custom_opt } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import click import typer class CustomClass : def __init__ ( self , value : str ): self . value = value def __repr__ ( self ): return f "<CustomClass: value= { self . value } >" class CustomClassParser ( click . ParamType ): name = "CustomClass" def convert ( self , value , param , ctx ): return CustomClass ( value * 3 ) def main ( custom_arg : CustomClass = typer . Argument ( click_type = CustomClassParser ()), custom_opt : CustomClass = typer . Option ( "Foo" , click_type = CustomClassParser ()), ): print ( f "custom_arg is { custom_arg } " ) print ( f "--custom-opt is { custom_opt } " ) if __name__ == "__main__" : typer . run ( main ) Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

File - Typer Skip to content Typer File Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File File Table of contents FileText reading FileTextWrite FileBinaryRead FileBinaryWrite File CLI parameter configurations Advanced mode Note about FileTextWrite Customize mode About the different types Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents FileText reading FileTextWrite FileBinaryRead FileBinaryWrite File CLI parameter configurations Advanced mode Note about FileTextWrite Customize mode About the different types File Apart from Path CLI parameters you can also declare some types of "files". Tip In most of the cases you are probably fine just using Path . You can read and write data with Path the same way. The difference is that these types will give you a Python file-like object instead of a Python Path . A "file-like object" is the same type of object returned by open() as in: with open ( 'file.txt' ) as f : # Here f is the file-like object read_data = f . read () print ( read_data ) But in some special use cases you might want to use these special types. For example if you are migrating an existing application. FileText reading ¬∂ typer.FileText gives you a file-like object for reading text, you will get str data from it. This means that even if your file has text written in a non-english language, e.g. a text.txt file with: la cig√ºe√±a trae al ni√±o You will have a str with the text inside, e.g.: content = "la cig√ºe√±a trae al ni√±o" instead of having bytes , e.g.: content = b "la cig \xc3\xbc e \xc3\xb1 a trae al ni \xc3\xb1 o" You will get all the correct editor support, attributes, methods, etc for the file-like object:` Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( config : Annotated [ typer . FileText , typer . Option ()]): for line in config : print ( f "Config line: { line } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( config : typer . FileText = typer . Option ( ... )): for line in config : print ( f "Config line: { line } " ) if __name__ == "__main__" : typer . run ( main ) Check it: // Create a quick text config $ echo "some settings" > config.txt // Add another line to the config to test it $ echo "some more settings" >> config.txt // Now run your program $ python main.py --config config.txt Config line: some settings Config line: some more settings FileTextWrite ¬∂ For writing text, you can use typer.FileTextWrite : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( config : Annotated [ typer . FileTextWrite , typer . Option ()]): config . write ( "Some config written by the app" ) print ( "Config written" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( config : typer . FileTextWrite = typer . Option ( ... )): config . write ( "Some config written by the app" ) print ( "Config written" ) if __name__ == "__main__" : typer . run ( main ) This would be for writing human text, like: some settings
la cig√ºe√±a trae al ni√±o ...not to write binary bytes . Check it: $ python main.py --config text.txt Config written // Check the contents of the file $ cat text.txt Some config written by the app Technical Details typer.FileTextWrite is a just a convenience class. It's the same as using typer.FileText and setting mode="w" . You will learn about mode later below. FileBinaryRead ¬∂ To read binary data you can use typer.FileBinaryRead . You will receive bytes from it. It's useful for reading binary files like images: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( file : Annotated [ typer . FileBinaryRead , typer . Option ()]): processed_total = 0 for bytes_chunk in file : # Process the bytes in bytes_chunk processed_total += len ( bytes_chunk ) print ( f "Processed bytes total: { processed_total } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( file : typer . FileBinaryRead = typer . Option ( ... )): processed_total = 0 for bytes_chunk in file : # Process the bytes in bytes_chunk processed_total += len ( bytes_chunk ) print ( f "Processed bytes total: { processed_total } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py --file lena.jpg Processed bytes total: 512 Processed bytes total: 1024 Processed bytes total: 1536 Processed bytes total: 2048 FileBinaryWrite ¬∂ To write binary data you can use typer.FileBinaryWrite . You would write bytes to it. It's useful for writing binary files like images. Have in mind that you have to pass bytes to its .write() method, not str . If you have a str , you have to encode it first to get bytes . Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( file : Annotated [ typer . FileBinaryWrite , typer . Option ()]): first_line_str = "some settings \n " # You cannot write str directly to a binary file, you have to encode it to get bytes first_line_bytes = first_line_str . encode ( "utf-8" ) # Then you can write the bytes file . write ( first_line_bytes ) # This is already bytes, it starts with b" second_line = b "la cig \xc3\xbc e \xc3\xb1 a trae al ni \xc3\xb1 o" file . write ( second_line ) print ( "Binary file written" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( file : typer . FileBinaryWrite = typer . Option ( ... )): first_line_str = "some settings \n " # You cannot write str directly to a binary file, you have to encode it to get bytes first_line_bytes = first_line_str . encode ( "utf-8" ) # Then you can write the bytes file . write ( first_line_bytes ) # This is already bytes, it starts with b" second_line = b "la cig \xc3\xbc e \xc3\xb1 a trae al ni \xc3\xb1 o" file . write ( second_line ) print ( "Binary file written" ) if __name__ == "__main__" : typer . run ( main ) $ python main.py --file binary.dat Binary file written // Check the binary file was created $ ls ./binary.dat ./binary.dat File CLI parameter configurations ¬∂ You can use several configuration parameters for these types (classes) in typer.Option() and typer.Argument() : mode : controls the " mode " to open the file with. It's automatically set for you by using the classes above. Read more about it below. encoding : to force a specific encoding, e.g. "utf-8" . lazy : delay I/O operations. Automatic by default. By default, when writing files, Click will generate a file-like object that is not yet the actual file. Once you start writing, it will go, open the file and start writing to it, but not before. This is mainly useful to avoid creating the file until you start writing to it. It's normally safe to leave this automatic. But you can overwrite it setting lazy=False . By default, it's lazy=True for writing and lazy=False for reading. atomic : if true, all writes will actually go to a temporal file and then moved to the final destination after completing. This is useful with files modified frequently by several users/programs. Advanced mode ¬∂ By default, Typer will configure the mode for you: typer.FileText : mode="r" , to read text. typer.FileTextWrite : mode="w" , to write text. typer.FileBinaryRead : mode="rb" , to read binary data. typer.FileBinaryWrite : mode="wb" , to write binary data. Note about FileTextWrite ¬∂ typer.FileTextWrite is actually just a convenience class. It's the same as using typer.FileText with mode="w" . But it's probably shorter and more intuitive as you can get it with autocompletion in your editor by just starting to type typer.File ... just like the other classes. Customize mode ¬∂ You can override the mode from the defaults above. For example, you could use mode="a" to write "appending" to the same file: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( config : Annotated [ typer . FileText , typer . Option ( mode = "a" )]): config . write ( "This is a single line \n " ) print ( "Config line written" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( config : typer . FileText = typer . Option ( ... , mode = "a" )): config . write ( "This is a single line \n " ) print ( "Config line written" ) if __name__ == "__main__" : typer . run ( main ) Tip As you are manually setting mode="a" , you can use typer.FileText or typer.FileTextWrite , both will work. Check it: $ python main.py --config config.txt Config line written // Run your program a couple more times to see how it appends instead of overwriting $ python main.py --config config.txt Config line written $ python main.py --config config.txt Config line written // Check the contents of the file, it should have each of the 3 lines appended $ cat config.txt This is a single line This is a single line This is a single line About the different types ¬∂ Info These are technical details about why the different types/classes provided by Typer . But you don't need this information to be able to use them. You can skip it. Typer provides you these different types (classes) because they inherit directly from the actual Python implementation that will be provided underneath for each case. This way your editor will give you the right type checks and completion for each type. Even if you use lazy . When you use lazy Click creates a especial object to delay writes, and serves as a "proxy" to the actual file that will be written. But this especial proxy object doesn't expose the attributes and methods needed for type checks and completion in the editor. If you access those attributes or call the methods, the "proxy" lazy object will call them in the final object and it will all work. But you wouldn't get autocompletion for them. But because these Typer classes inherit from the actual implementation that will be provided underneath (not the lazy object), you will get all the autocompletion and type checks in the editor. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

DateTime - Typer Skip to content Typer DateTime Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime DateTime Table of contents Custom date format Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Custom date format DateTime You can specify a CLI parameter as a Python datetime . Your function will receive a standard Python datetime object, and again, your editor will give you completion, etc. from datetime import datetime import typer def main ( birth : datetime ): print ( f "Interesting day to be born: { birth } " ) print ( f "Birth hour: { birth . hour } " ) if __name__ == "__main__" : typer . run ( main ) Typer will accept any string from the following formats: %Y-%m-%d %Y-%m-%dT%H:%M:%S %Y-%m-%d %H:%M:%S Check it: $ python main.py --help Usage: main.py [OPTIONS] BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S] Arguments: BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S][required] Options: --help                Show this message and exit. // Pass a datetime $ python main.py 1956 -01-31T10:00:00 Interesting day to be born: 1956-01-31 10:00:00 Birth hour: 10 // An invalid date $ python main.py july-19-1989 Usage: main.py [OPTIONS] [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d%H:%M:%S] Error: Invalid value for '[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]': invalid datetime format: july-19-1989. (choose from %Y-%m-%d, %Y-%m-%dT%H:%M:%S, %Y-%m-%d %H:%M:%S) Custom date format ¬∂ You can also customize the formats received for the datetime with the formats parameter. formats receives a list of strings with the date formats that would be passed to datetime.strptime() . For example, let's imagine that you want to accept an ISO formatted datetime, but for some strange reason, you also want to accept a format with: first the month then the day then the year separated with " / " ...It's a crazy example, but let's say you also needed that strange format: Python 3.6+ Python 3.6+ non-Annotated from datetime import datetime import typer from typing_extensions import Annotated def main ( launch_date : Annotated [ datetime , typer . Argument ( formats = [ "%Y-%m- %d " , "%Y-%m- %d T%H:%M:%S" , "%Y-%m- %d %H:%M:%S" , "%m/ %d /%Y" ] ), ] ): print ( f "Launch will be at: { launch_date } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from datetime import datetime import typer def main ( launch_date : datetime = typer . Argument ( ... , formats = [ "%Y-%m- %d " , "%Y-%m- %d T%H:%M:%S" , "%Y-%m- %d %H:%M:%S" , "%m/ %d /%Y" ] ) ): print ( f "Launch will be at: { launch_date } " ) if __name__ == "__main__" : typer . run ( main ) Tip Notice the last string in formats : "%m/%d/%Y" . Check it: // ISO dates work $ python main.py 1969 -10-29 Launch will be at: 1969-10-29 00:00:00 // But the strange custom format also works $ python main.py 10 /29/1969 Launch will be at: 1969-10-29 00:00:00 Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Path - Typer Skip to content Typer Path Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path Path Table of contents Path validations Advanced Path configurations File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Path validations Advanced Path configurations Path You can declare a CLI parameter to be a standard Python pathlib.Path . This is what you would do for directory paths, file paths, etc: Python 3.6+ Python 3.6+ non-Annotated from pathlib import Path from typing import Optional import typer from typing_extensions import Annotated def main ( config : Annotated [ Optional [ Path ], typer . Option ()] = None ): if config is None : print ( "No config file" ) raise typer . Abort () if config . is_file (): text = config . read_text () print ( f "Config file contents: { text } " ) elif config . is_dir (): print ( "Config is a directory, will use all its config files" ) elif not config . exists (): print ( "The config doesn't exist" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from pathlib import Path from typing import Optional import typer def main ( config : Optional [ Path ] = typer . Option ( None )): if config is None : print ( "No config file" ) raise typer . Abort () if config . is_file (): text = config . read_text () print ( f "Config file contents: { text } " ) elif config . is_dir (): print ( "Config is a directory, will use all its config files" ) elif not config . exists (): print ( "The config doesn't exist" ) if __name__ == "__main__" : typer . run ( main ) And again, as you receive a standard Python Path object the same as the type annotation, your editor will give you autocompletion for all its attributes and methods. Check it: // No config $ python main.py No config file Aborted! // Pass a config that doesn't exist $ python main.py --config config.txt The config doesn't exist // Now create a quick config $ echo "some settings" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Config is a directory, will use all its config files Path validations ¬∂ You can perform several validations for Path CLI parameters : exists : if set to true, the file or directory needs to exist for this value to be valid. If this is not required and a file does indeed not exist, then all further checks are silently skipped. file_okay : controls if a file is a possible value. dir_okay : controls if a directory is a possible value. writable : if true, a writable check is performed. readable : if true, a readable check is performed. resolve_path : if this is true, then the path is fully resolved before the value is passed onwards. This means that it‚Äôs absolute and symlinks are resolved. Technical Details It will not expand a tilde-prefix (something with ~ , like ~/Documents/ ), as this is supposed to be done by the shell only. Tip All these parameters come directly from Click . For example: Python 3.6+ Python 3.6+ non-Annotated from pathlib import Path import typer from typing_extensions import Annotated def main ( config : Annotated [ Path , typer . Option ( exists = True , file_okay = True , dir_okay = False , writable = False , readable = True , resolve_path = True , ), ] ): text = config . read_text () print ( f "Config file contents: { text } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from pathlib import Path import typer def main ( config : Path = typer . Option ( ... , exists = True , file_okay = True , dir_okay = False , writable = False , readable = True , resolve_path = True , ) ): text = config . read_text () print ( f "Config file contents: { text } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py --config config.txt Usage: main.py [OPTIONS] Try "main.py --help" for help. Error: Invalid value for '--config': File 'config.txt' does not exist. // Now create a quick config $ echo "some settings" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Usage: main.py [OPTIONS] Try "main.py --help" for help. Error: Invalid value for '--config': File './' is a directory. Advanced Path configurations ¬∂ Advanced Details You probably won't need these configurations at first, you may want to skip it. They are used for more advanced use cases. allow_dash : If this is set to True, a single dash to indicate standard streams is permitted. path_type : optionally a string type that should be used to represent the path. The default is None which means the return value will be either bytes or unicode depending on what makes most sense given the input data Click deals with. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Enum - Choices - Typer Skip to content Typer Enum - Choices Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Enum - Choices Table of contents Case insensitive Enum choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Case insensitive Enum choices Enum - Choices To define a CLI parameter that can take a value from a predefined set of values you can use a standard Python enum.Enum : from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = "simple" conv = "conv" lstm = "lstm" def main ( network : NeuralNetwork = NeuralNetwork . simple ): print ( f "Training neural network of type: { network . value } " ) if __name__ == "__main__" : typer . run ( main ) Tip Notice that the function parameter network will be an Enum , not a str . To get the str value in your function's code use network.value . Check it: $ python main.py --help // Notice the predefined values [simple|conv|lstm] Usage: main.py [OPTIONS] Options: --network [simple|conv|lstm]  [default: simple] --help                        Show this message and exit. // Try it $ python main.py --network conv Training neural network of type: conv // Invalid value $ python main.py --network capsule Usage: main.py [OPTIONS] Try "main.py --help" for help. Error: Invalid value for '--network': invalid choice: capsule. (choose from simple, conv, lstm) Case insensitive Enum choices ¬∂ You can make an Enum (choice) CLI parameter be case-insensitive with the case_sensitive parameter: Python 3.6+ Python 3.6+ non-Annotated from enum import Enum import typer from typing_extensions import Annotated class NeuralNetwork ( str , Enum ): simple = "simple" conv = "conv" lstm = "lstm" def main ( network : Annotated [ NeuralNetwork , typer . Option ( case_sensitive = False ) ] = NeuralNetwork . simple ): print ( f "Training neural network of type: { network . value } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = "simple" conv = "conv" lstm = "lstm" def main ( network : NeuralNetwork = typer . Option ( NeuralNetwork . simple , case_sensitive = False ) ): print ( f "Training neural network of type: { network . value } " ) if __name__ == "__main__" : typer . run ( main ) And then the values of the Enum will be checked no matter if lower case, upper case, or a mix: // Notice the upper case CONV $ python main.py --network CONV Training neural network of type: conv // A mix also works $ python main.py --network LsTm Training neural network of type: lstm Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Number - Typer Skip to content Typer Number Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Number Table of contents Clamping numbers Counter CLI options Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Clamping numbers Counter CLI options Number You can define numeric validations with max and min values for int and float CLI parameters : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( id : Annotated [ int , typer . Argument ( min = 0 , max = 1000 )], age : Annotated [ int , typer . Option ( min = 18 )] = 20 , score : Annotated [ float , typer . Option ( max = 100 )] = 0 , ): print ( f "ID is { id } " ) print ( f "--age is { age } " ) print ( f "--score is { score } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), age : int = typer . Option ( 20 , min = 18 ), score : float = typer . Option ( 0 , max = 100 ), ): print ( f "ID is { id } " ) print ( f "--age is { age } " ) print ( f "--score is { score } " ) if __name__ == "__main__" : typer . run ( main ) CLI arguments and CLI options can both use these validations. You can specify min , max or both. Check it: $ python main.py --help // Notice the extra RANGE in the help text for --age and --score Usage: main.py [OPTIONS] ID Arguments: ID  [required] Options: --age INTEGER RANGE   [default: 20] --score FLOAT RANGE   [default: 0] --help                Show this message and exit. // Pass all the CLI parameters $ python main.py 5 --age 20 --score 90 ID is 5 --age is 20 --score is 90.0 // Pass an invalid ID $ python main.py 1002 Usage: main.py [OPTIONS] ID Try "main.py --help" for help. Error: Invalid value for 'ID': 1002 is not in the valid range of 0 to 1000. // Pass an invalid age $ python main.py 5 --age 15 Usage: main.py [OPTIONS] ID Try "main.py --help" for help. Error: Invalid value for '--age': 15 is smaller than the minimum valid value 18. // Pass an invalid score $ python main.py 5 --age 20 --score 100 .5 Usage: main.py [OPTIONS] ID Try "main.py --help" for help. Error: Invalid value for '--score': 100.5 is bigger than the maximum valid value 100. // But as we didn't specify a minimum score, this is accepted $ python main.py 5 --age 20 --score -5 ID is 5 --age is 20 --score is -5.0 Clamping numbers ¬∂ You might want to, instead of showing an error, use the closest minimum or maximum valid values. You can do it with the clamp parameter: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( id : Annotated [ int , typer . Argument ( min = 0 , max = 1000 )], rank : Annotated [ int , typer . Option ( max = 10 , clamp = True )] = 0 , score : Annotated [ float , typer . Option ( min = 0 , max = 100 , clamp = True )] = 0 , ): print ( f "ID is { id } " ) print ( f "--rank is { rank } " ) print ( f "--score is { score } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), rank : int = typer . Option ( 0 , max = 10 , clamp = True ), score : float = typer . Option ( 0 , min = 0 , max = 100 , clamp = True ), ): print ( f "ID is { id } " ) print ( f "--rank is { rank } " ) print ( f "--score is { score } " ) if __name__ == "__main__" : typer . run ( main ) And then, when you pass data that is out of the valid range, it will be "clamped", the closest valid value will be used: // ID doesn't have clamp, so it shows an error $ python main.py 1002 Usage: main.py [OPTIONS] ID Try "main.py --help" for help. Error: Invalid value for 'ID': 1002 is not in the valid range of 0 to 1000. // But --rank and --score use clamp $ python main.py 5 --rank 11 --score -5 ID is 5 --rank is 10 --score is 0 Counter CLI options ¬∂ You can make a CLI option work as a counter with the counter parameter: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( verbose : Annotated [ int , typer . Option ( "--verbose" , "-v" , count = True )] = 0 ): print ( f "Verbose level is { verbose } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( verbose : int = typer . Option ( 0 , "--verbose" , "-v" , count = True )): print ( f "Verbose level is { verbose } " ) if __name__ == "__main__" : typer . run ( main ) It means that the CLI option will be like a boolean flag, e.g. --verbose . And the value you receive in the function will be the amount of times that --verbose was added: // Check it $ python main.py Verbose level is 0 // Now use one --verbose $ python main.py --verbose Verbose level is 1 // Now 3 --verbose $ python main.py --verbose --verbose --verbose Verbose level is 3 // And with the short name $ python main.py -v Verbose level is 1 // And with the short name 3 times $ python main.py -v -v -v Verbose level is 3 // As short names can be put together, this also works $ python main.py -vvv Verbose level is 3 Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Boolean CLI Options - Typer Skip to content Typer Boolean CLI Options Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options Boolean CLI Options Table of contents Only --force Alternative names Short names Only names for False UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Only --force Alternative names Short names Only names for False Boolean CLI Options We have seen some examples of CLI options with bool , and how Typer creates --something and --no-something automatically. But we can customize those names. Only --force ¬∂ Let's say that we want a --force CLI option only, we want to discard --no-force . We can do that by specifying the exact name we want: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( force : Annotated [ bool , typer . Option ( "--force" )] = False ): if force : print ( "Forcing operation" ) else : print ( "Not forcing" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( force : bool = typer . Option ( False , "--force" )): if force : print ( "Forcing operation" ) else : print ( "Not forcing" ) if __name__ == "__main__" : typer . run ( main ) Now there's only a --force CLI option : // Check the help $ python main.py --help // Notice there's only --force, we no longer have --no-force Usage: main.py [OPTIONS] Options: --force               [default: False] --help                Show this message and exit. // Try it: $ python main.py Not forcing // Now add --force $ python main.py --force Forcing operation // And --no-force no longer exists ‚õîÔ∏è $ python main.py --no-force Usage: main.py [OPTIONS] Try "main.py --help" for help. Error: no such option: --no-force Alternative names ¬∂ Now let's imagine we have a CLI option --accept . And we want to allow setting --accept or the contrary, but --no-accept looks ugly. We might want to instead have --accept and --reject . We can do that by passing a single str with the 2 names for the bool CLI option separated by / : Python 3.6+ Python 3.6+ non-Annotated from typing import Optional import typer from typing_extensions import Annotated def main ( accept : Annotated [ Optional [ bool ], typer . Option ( "--accept/--reject" )] = None ): if accept is None : print ( "I don't know what you want yet" ) elif accept : print ( "Accepting!" ) else : print ( "Rejecting!" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import Optional import typer def main ( accept : Optional [ bool ] = typer . Option ( None , "--accept/--reject" )): if accept is None : print ( "I don't know what you want yet" ) elif accept : print ( "Accepting!" ) else : print ( "Rejecting!" ) if __name__ == "__main__" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the --accept / --reject Usage: main.py [OPTIONS] Options: --accept / --reject --help                Show this message and exit. // Try it $ python main.py I don't know what you want yet // Now pass --accept $ python main.py --accept Accepting! // And --reject $ python main.py --reject Rejecting! Short names ¬∂ The same way, you can declare short versions of the names for these CLI options . For example, let's say we want -f for --force and -F for --no-force : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( force : Annotated [ bool , typer . Option ( "--force/--no-force" , "-f/-F" )] = False ): if force : print ( "Forcing operation" ) else : print ( "Not forcing" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( force : bool = typer . Option ( False , "--force/--no-force" , "-f/-F" )): if force : print ( "Forcing operation" ) else : print ( "Not forcing" ) if __name__ == "__main__" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the -f, --force / -F, --no-force Usage: main.py [OPTIONS] Options: -f, --force / -F, --no-force  [default: False] --help                        Show this message and exit. // Try with the short name -f $ python main.py -f Forcing operation // Try with the short name -F $ python main.py -F Not forcing Only names for False ¬∂ If you want to (although it might not be a good idea), you can declare only CLI option names to set the False value. To do that, use a space and a single / and pass the negative name after: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( in_prod : Annotated [ bool , typer . Option ( " /--demo" , " /-d" )] = True ): if in_prod : print ( "Running in production" ) else : print ( "Running demo" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( in_prod : bool = typer . Option ( True , " /--demo" , " /-d" )): if in_prod : print ( "Running in production" ) else : print ( "Running demo" ) if __name__ == "__main__" : typer . run ( main ) Tip Have in mind that it's a string with a preceding space and then a / . So, it's " /-S" not "/-S" . Check it: // Check the help $ python main.py --help // Notice the / -d, --demo Usage: main.py [OPTIONS] Options: / -d, --demo         [default: True] --help                Show this message and exit. // Try it $ python main.py Running in production // Now pass --demo $ python main.py --demo Running demo // And the short version $ python main.py -d Running demo Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

UUID - Typer Typer UUID Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes UUID Info A UUID is a "Universally Unique Identifier" . It's a standard format for identifiers, like passport numbers, but for anything, not just people in countries. They look like this: d48edaa6-871a-4082-a196-4daab372d4a1 The way they are generated makes them sufficiently long and random that you could assume that every UUID generated is unique. Even if it was generated by a different application, database, or system. So, if your system uses UUIDs to identify your data, you could mix it with the data from some other system that also uses UUIDs with some confidence that their IDs (UUIDs) won't clash with yours. This wouldn't be true if you just used int s as identifiers, as most databases do. You can declare a CLI parameter as a UUID: from uuid import UUID import typer def main ( user_id : UUID ): print ( f "USER_ID is { user_id } " ) print ( f "UUID version is: { user_id . version } " ) if __name__ == "__main__" : typer . run ( main ) Your Python code will receive a standard Python UUID object with all its attributes and methods, and as you are annotating your function parameter with that type, you will have type checks, autocompletion in your editor, etc. Check it: // Pass a valid UUID v4 $ python main.py d48edaa6-871a-4082-a196-4daab372d4a1 USER_ID is d48edaa6-871a-4082-a196-4daab372d4a1 UUID version is: 4 // An invalid value $ python main.py 7479706572 -72756c6573 Usage: main.py [OPTIONS] USER_ID Try "main.py --help" for help. Error: Invalid value for 'USER_ID': 7479706572-72756c6573 is not a valid UUID value Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Printing and Colors - Typer Skip to content Typer Printing and Colors Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Printing and Colors Table of contents Use Rich Install Rich Use Rich print Rich Markup Rich Tables Typer and Rich "Standard Output" and "Standard Error" Standard Error Printing to "standard error" "Standard Input" What is this for Typer Echo Why typer.echo Color typer.secho() - style and print Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Use Rich Install Rich Use Rich print Rich Markup Rich Tables Typer and Rich "Standard Output" and "Standard Error" Standard Error Printing to "standard error" "Standard Input" What is this for Typer Echo Why typer.echo Color typer.secho() - style and print Printing and Colors You can use the normal print() to show information on the screen: import typer def main (): print ( "Hello World" ) if __name__ == "__main__" : typer . run ( main ) It will show the output normally: $ python main.py Hello World Use Rich ¬∂ You can also display beautiful and more complex information using Rich . Install Rich ¬∂ First, you need to install it: // Rich comes with typer[all] $ pip install "typer[all]" ---> 100% Successfully installed typer rich // Alternatively, you can install Rich independently $ pip install rich ---> 100% Successfully installed rich Use Rich print ¬∂ For the simplest cases, you can just import print from rich and use it instead of the standard print : import typer from rich import print data = { "name" : "Rick" , "age" : 42 , "items" : [{ "name" : "Portal Gun" }, { "name" : "Plumbus" }], "active" : True , "affiliation" : None , } def main (): print ( "Here's the data" ) print ( data ) if __name__ == "__main__" : typer . run ( main ) Just with that, Rich will be able to print your data with nice colors and structure: $ python main.py Here's the data <b>{</b> <font color="#A6E22E">&apos;name&apos;</font>: <font color="#A6E22E">&apos;Rick&apos;</font>, <font color="#A6E22E">&apos;age&apos;</font>: <font color="#A1EFE4"><b>42</b></font>, <font color="#A6E22E">&apos;items&apos;</font>: <b>[</b> <b>{</b><font color="#A6E22E">&apos;name&apos;</font>: <font color="#A6E22E">&apos;Portal Gun&apos;</font><b>}</b>, <b>{</b><font color="#A6E22E">&apos;name&apos;</font>: <font color="#A6E22E">&apos;Plumbus&apos;</font><b>}</b> <b>]</b>, <font color="#A6E22E">&apos;active&apos;</font>: <font color="#A6E22E"><i>True</i></font>, <font color="#A6E22E">&apos;affiliation&apos;</font>: <font color="#AE81FF"><i>None</i></font> <b>}</b> Rich Markup ¬∂ Rich also supports a custom markup syntax to set colors and styles, for example: import typer from rich import print def main (): print ( "[bold red]Alert![/bold red] [green]Portal gun[/green] shooting! :boom:" ) if __name__ == "__main__" : typer . run ( main ) $ python main.py <font color="#F92672"><b>Alert!</b></font> <font color="#A6E22E">Portal gun</font> shooting! üí• In this example you can see how to use font styles, colors, and even emojis. To learn more check out the Rich docs . Rich Tables ¬∂ The way Rich works internally is that it uses a Console object to display the information. When you call Rich's print , it automatically creates this object and uses it. But for advanced use cases, you could create a Console yourself. import typer from rich.console import Console from rich.table import Table console = Console () def main (): table = Table ( "Name" , "Item" ) table . add_row ( "Rick" , "Portal Gun" ) table . add_row ( "Morty" , "Plumbus" ) console . print ( table ) if __name__ == "__main__" : typer . run ( main ) In this example, we create a Console , and a Table . And then we can add some rows to the table, and print it. If you run it, you will see a nicely formatted table: $ python main.py ‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì ‚îÉ<b> Name  </b>‚îÉ<b> Item       </b>‚îÉ ‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î© ‚îÇ Rick  ‚îÇ Portal Gun ‚îÇ ‚îÇ Morty ‚îÇ Plumbus    ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Rich has many other features, as an example, you can check the docs for: Prompt Markdown Panel ...and more. Typer and Rich ¬∂ If you are wondering what tool should be used for what, Typer is useful for structuring the command line application, with options, arguments, subcommands, data validation, etc. In general, Typer tends to be the entry point to your program, taking the first input from the user. Rich is useful for the parts that need to display information. Showing beautiful content on the screen. The best results for your command line application would be achieved combining both Typer and Rich . "Standard Output" and "Standard Error" ¬∂ The way printing works underneath is that the operating system (Linux, Windows, macOS) treats what we print as if our CLI program was writing text to a " virtual file " called " standard output ". When our code "prints" things it is actually "writing" to this "virtual file" of "standard output". This might seem strange, but that's how the CLI program and the operating system interact with each other. And then the operating system shows on the screen whatever our CLI program " wrote " to that " virtual file " called " standard output ". Standard Error ¬∂ And there's another " virtual file " called " standard error " that is normally only used for errors. But we can also "print" to "standard error". And both are shown on the terminal to the users. Info If you use PowerShell it's quite possible that what you print to "standard error" won't be shown in the terminal. In PowerShell, to see "standard error" you would have to check the variable $Error . But it will work normally in Bash, Zsh, and Fish. Printing to "standard error" ¬∂ You can print to "standard error" creating a Rich Console with stderr=True . Tip stderr is short for "standard error". Using stderr=True tells Rich that the output should be shown in "standard error". import typer from rich.console import Console err_console = Console ( stderr = True ) def main (): err_console . print ( "Here is something written to standard error" ) if __name__ == "__main__" : typer . run ( main ) When you try it in the terminal, it will probably just look the same: $ python main.py Here is something written to standard error "Standard Input" ¬∂ As a final detail, when you type text in your keyboard to your terminal, the operating system also considers it another " virtual file " that you are writing text to. This virtual file is called " standard input ". What is this for ¬∂ Right now this probably seems quite useless ü§∑‚Äç‚ôÇ. But understanding that will come handy in the future, for example for autocompletion and testing. Typer Echo ¬∂ Warning In most of the cases, for displaying advanced information, it is recommended to use Rich . You can probably skip the rest of this section. üéâüòé Typer also has a small utility typer.echo() to print information on the screen, it comes directly from Click. But normally you shouldn't need it. For the simplest cases, you can use the standard Python print() . And for the cases where you want to display data more beautifully, or more advanced content, you should use Rich instead. Why typer.echo ¬∂ typer.echo() (which is actually just click.echo() ) applies some checks to try and convert binary data to strings, and other similar things. But in most of the cases you wouldn't need it, as in modern Python strings ( str ) already support and use Unicode, and you would rarely deal with pure bytes that you want to print on the screen. If you have some bytes objects, you would probably want to decode them intentionally and directly before trying to print them. And if you want to print data with colors and other features, you are much better off with the more advanced tools in Rich . Info typer.echo() comes directly from Click, you can read more about it in Click's docs . Color ¬∂ Technical Details The way color works in terminals is by using some codes (ANSI escape sequences) as part of the text. So, a colored text is still just a str . Tip Again, you are much better off using Rich for this. üòé You can create colored strings to output to the terminal with typer.style() , that gives you str s that you can then pass to typer.echo() : import typer def main ( good : bool = True ): message_start = "everything is " if good : ending = typer . style ( "good" , fg = typer . colors . GREEN , bold = True ) else : ending = typer . style ( "bad" , fg = typer . colors . WHITE , bg = typer . colors . RED ) message = message_start + ending typer . echo ( message ) if __name__ == "__main__" : typer . run ( main ) Tip The parameters fg and bg receive strings with the color names for the " f ore g round" and " b ack g round" colors. You could simply pass fg="green" and bg="red" . But Typer provides them all as variables like typer.colors.GREEN just so you can use autocompletion while selecting them. Check it: python main.py everything is good python main.py --no-good everything is bad You can pass these function arguments to typer.style() : fg : the foreground color. bg : the background color. bold : enable or disable bold mode. dim : enable or disable dim mode. This is badly supported. underline : enable or disable underline. blink : enable or disable blinking. reverse : enable or disable inverse rendering (foreground becomes background and the other way round). reset : by default a reset-all code is added at the end of the string which means that styles do not carry over.  This can be disabled to compose styles. Info You can read more about it in Click's docs about style() typer.secho() - style and print ¬∂ Tip In case you didn't see above, you are much better off using Rich for this. üòé There's a shorter form to style and print at the same time with typer.secho() it's like typer.echo() but also adds style like typer.style() : import typer def main ( name : str ): typer . secho ( f "Welcome here { name } " , fg = typer . colors . MAGENTA ) if __name__ == "__main__" : typer . run ( main ) Check it: python main.py Camila Welcome here Camila Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Option autocompletion - Typer Skip to content Typer CLI Option autocompletion Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Option autocompletion Table of contents Review completion Custom completion for values Check the incomplete value Add help to completions Simplify with yield Access other CLI parameters with the Context Getting completion for multiple values Getting the raw CLI parameters Printing to "standard error" Getting the Context and the raw CLI parameters Types, types everywhere CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Review completion Custom completion for values Check the incomplete value Add help to completions Simplify with yield Access other CLI parameters with the Context Getting completion for multiple values Getting the raw CLI parameters Printing to "standard error" Getting the Context and the raw CLI parameters Types, types everywhere CLI Option autocompletion As you have seen, apps built with Typer have completion in your shell that works when you create a Python package or using Typer CLI . It normally completes CLI options , CLI arguments , and subcommands (that you will learn about later). But you can also provide auto completion for the values of CLI options and CLI arguments . We will learn about that here. Review completion ¬∂ Before checking how to provide custom completions, let's check again how it works. After installing completion (for your own Python package or for Typer CLI ), when you use your CLI program and start adding a CLI option with -- an then hit TAB , your shell will show you the available CLI options (the same for CLI arguments , etc). To check it quickly without creating a new Python package, install Typer CLI . Then let's create small example program: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated app = typer . Typer () @app . command () def main ( name : Annotated [ str , typer . Option ( help = "The name to say hi to." )] = "World" ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer () @app . command () def main ( name : str = typer . Option ( "World" , help = "The name to say hi to." )): print ( f "Hello { name } " ) if __name__ == "__main__" : app () And let's try it with Typer CLI to get completion: // Hit the TAB key in your keyboard below where you see the: [TAB] $ typer ./main.py [ TAB ][ TAB ] // Depending on your terminal/shell you will get some completion like this ‚ú® run    -- Run the provided Typer app. utils  -- Extra utility commands for Typer apps. // Then try with "run" and -- $ typer ./main.py run -- [ TAB ][ TAB ] // You will get completion for --name, depending on your terminal it will look something like this --name  -- The name to say hi to. // And you can run it as if it was with Python directly $ typer ./main.py run --name Camila Hello Camila Custom completion for values ¬∂ Right now we get completion for the CLI option names, but not for the values. We can provide completion for the values creating an autocompletion function, similar to the callback functions from CLI Option Callback and Context : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def complete_name (): return [ "Camila" , "Carlos" , "Sebastian" ] app = typer . Typer () @app . command () def main ( name : Annotated [ str , typer . Option ( help = "The name to say hi to." , autocompletion = complete_name ) ] = "World" , ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer def complete_name (): return [ "Camila" , "Carlos" , "Sebastian" ] app = typer . Typer () @app . command () def main ( name : str = typer . Option ( "World" , help = "The name to say hi to." , autocompletion = complete_name ) ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () We return a list of strings from the complete_name() function. And then we get those values when using completion: $ typer ./main.py run --name [ TAB ][ TAB ] // We get the values returned from the function üéâ Camila     Carlos     Sebastian We got the basics working. Now let's improve it. Check the incomplete value ¬∂ Right now, we always return those values, even if users start typing Sebast and then hit TAB , they will also get the completion for Camila and Carlos (depending on the shell), while we should only get completion for Sebastian . But we can fix that so that it always works correctly. Modify the complete_name() function to receive a parameter of type str , it will contain the incomplete value. Then we can check and return only the values that start with the incomplete value from the command line: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated valid_names = [ "Camila" , "Carlos" , "Sebastian" ] def complete_name ( incomplete : str ): completion = [] for name in valid_names : if name . startswith ( incomplete ): completion . append ( name ) return completion app = typer . Typer () @app . command () def main ( name : Annotated [ str , typer . Option ( help = "The name to say hi to." , autocompletion = complete_name ) ] = "World" , ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer valid_names = [ "Camila" , "Carlos" , "Sebastian" ] def complete_name ( incomplete : str ): completion = [] for name in valid_names : if name . startswith ( incomplete ): completion . append ( name ) return completion app = typer . Typer () @app . command () def main ( name : str = typer . Option ( "World" , help = "The name to say hi to." , autocompletion = complete_name ) ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Now let's try it: $ typer ./main.py run --name Ca [ TAB ][ TAB ] // We get the values returned from the function that start with Ca üéâ Camila     Carlos Now we are only returning the valid values, that start with Ca , we are no longer returning Sebastian as a completion option. Tip You have to declare the incomplete value of type str and that's what you will receive in the function. No matter if the actual value will be an int , or something else, when doing completion, you will only get a str as the incomplete value. And the same way, you can only return str , not int , etc. Add help to completions ¬∂ Right now we are returning a list of str . But some shells (Zsh, Fish, PowerShell) are capable of showing extra help text for completion. We can provide that extra help text so that those shells can show it. In the complete_name() function, instead of providing one str per completion element, we provide a tuple with 2 items. The first item is the actual completion string, and the second item is the help text. So, in the end, we return a list of tuples of str : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] def complete_name ( incomplete : str ): completion = [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ): completion_item = ( name , help_text ) completion . append ( completion_item ) return completion app = typer . Typer () @app . command () def main ( name : Annotated [ str , typer . Option ( help = "The name to say hi to." , autocompletion = complete_name ) ] = "World" , ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] def complete_name ( incomplete : str ): completion = [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ): completion_item = ( name , help_text ) completion . append ( completion_item ) return completion app = typer . Typer () @app . command () def main ( name : str = typer . Option ( "World" , help = "The name to say hi to." , autocompletion = complete_name ) ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Tip If you want to have help text for each item, make sure each item in the list is a tuple . Not a list . Click checks specifically for a tuple when extracting the help text. So in the end, the return will be a list (or other iterable) of tuples of 2 str . Info The help text will be visible in Zsh, Fish, and PowerShell. Bash doesn't support showing the help text, but completion will still work the same. If you have a shell like Zsh, it would look like: $ typer ./main.py run --name [ TAB ][ TAB ] // We get the completion items with their help text üéâ Camila     -- The reader of books. Carlos     -- The writer of scripts. Sebastian  -- The type hints guy. Simplify with yield ¬∂ Instead of creating and returning a list with values ( str or tuple ), we can use yield with each value that we want in the completion. That way our function will be a generator that Typer (actually Click) can iterate: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] def complete_name ( incomplete : str ): for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : Annotated [ str , typer . Option ( help = "The name to say hi to." , autocompletion = complete_name ) ] = "World" , ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] def complete_name ( incomplete : str ): for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : str = typer . Option ( "World" , help = "The name to say hi to." , autocompletion = complete_name ) ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () That simplifies our code a bit and works the same. Tip If all the yield part seems complex for you, don't worry, you can just use the version with the list above. In the end, that's just to save us a couple of lines of code. Info The function can use yield , so it doesn't have to return strictly a list , it just has to be iterable . But each of the elements for completion has to be a str or a tuple (when containing a help text). Access other CLI parameters with the Context ¬∂ Let's say that now we want to modify the program to be able to "say hi" to multiple people at the same time. So, we will allow multiple --name CLI options . Tip You will learn more about CLI parameters with multiple values later in the tutorial. So, for now, take this as a sneak peek üòâ. For this we use a List of str : Python 3.6+ Python 3.6+ non-Annotated from typing import List import typer from typing_extensions import Annotated app = typer . Typer () @app . command () def main ( name : Annotated [ List [ str ], typer . Option ( help = "The name to say hi to." )] = [ "World" ] ): for each_name in name : print ( f "Hello { each_name } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. from typing import List import typer app = typer . Typer () @app . command () def main ( name : List [ str ] = typer . Option ([ "World" ], help = "The name to say hi to." )): for each_name in name : print ( f "Hello { each_name } " ) if __name__ == "__main__" : app () And then we can use it like: $ typer ./main.py run --name Camila --name Sebastian Hello Camila Hello Sebastian Getting completion for multiple values ¬∂ And the same way as before, we want to provide completion for those names. But we don't want to provide the same names for completion if they were already given in previous parameters. For that, we will access and use the "Context". When you create a Typer application it uses Click underneath. And every Click application has a special object called a "Context" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . And from that context you can get the current values for each parameter. Python 3.6+ Python 3.6+ non-Annotated from typing import List import typer from typing_extensions import Annotated valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] def complete_name ( ctx : typer . Context , incomplete : str ): names = ctx . params . get ( "name" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : Annotated [ List [ str ], typer . Option ( help = "The name to say hi to." , autocompletion = complete_name ), ] = [ "World" ], ): for n in name : print ( f "Hello { n } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. from typing import List import typer valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] def complete_name ( ctx : typer . Context , incomplete : str ): names = ctx . params . get ( "name" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : List [ str ] = typer . Option ( [ "World" ], help = "The name to say hi to." , autocompletion = complete_name ) ): for n in name : print ( f "Hello { n } " ) if __name__ == "__main__" : app () We are getting the names already provided with --name in the command line before this completion was triggered. If there's no --name in the command line, it will be None , so we use or [] to make sure we have a list (even if empty) to check its contents later. Then, when we have a completion candidate, we check if each name was already provided with --name by checking if it's in that list of names with name not in names . And then we yield each item that has not been used yet. Check it: $ typer ./main.py run --name [ TAB ][ TAB ] // The first time we trigger completion, we get all the names Camila     -- The reader of books. Carlos     -- The writer of scripts. Sebastian  -- The type hints guy. // Add a name and trigger completion again $ typer ./main.py run --name Sebastian --name Ca [ TAB ][ TAB ] // Now we get completion only for the names we haven't used üéâ Camila  -- The reader of books. Carlos  -- The writer of scripts. // And if we add another of the available names: $ typer ./main.py run --name Sebastian --name Camila --name [ TAB ][ TAB ] // We get completion for the only available one Carlos  -- The writer of scripts. Tip It's quite possible that if there's only one option left, your shell will complete it right away instead of showing the option with the help text, to save you more typing. Getting the raw CLI parameters ¬∂ You can also get the raw CLI parameters , just a list of str with everything passed in the command line before the incomplete value. For example, something like ["typer", "main.py", "run", "--name"] . Tip This would be for advanced scenarios, in most use cases you would be better off using the context. But it's still possible if you need it. As a simple example, let's show it on the screen before completion. Because completion is based on the output printed by your program (handled internally by Typer ), during completion we can't just print something else as we normally do. Printing to "standard error" ¬∂ Tip If you need a refresher about what is "standard output" and "standard error" check the section in Printing and Colors: "Standard Output" and "Standard Error" . The completion system only reads from "standard output", so, printing to "standard error" won't break completion. üöÄ You can print to "standard error" with a Rich Console(stderr=True) . Using stderr=True tells Rich that the output should be shown in "standard error". Python 3.6+ Python 3.6+ non-Annotated from typing import List import typer from rich.console import Console from typing_extensions import Annotated valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] err_console = Console ( stderr = True ) def complete_name ( args : List [ str ], incomplete : str ): err_console . print ( f " { args } " ) for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : Annotated [ List [ str ], typer . Option ( help = "The name to say hi to." , autocompletion = complete_name ), ] = [ "World" ], ): for n in name : print ( f "Hello { n } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. from typing import List import typer from rich.console import Console valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] err_console = Console ( stderr = True ) def complete_name ( args : List [ str ], incomplete : str ): err_console . print ( f " { args } " ) for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : List [ str ] = typer . Option ( [ "World" ], help = "The name to say hi to." , autocompletion = complete_name ) ): for n in name : print ( f "Hello { n } " ) if __name__ == "__main__" : app () Info If you can't install and use Rich, you can also use print(lastname, file=sys.stderr) or typer.echo("some text", err=True) instead. We get all the CLI parameters as a raw list of str by declaring a parameter with type List[str] , here it's named args . Tip Here we name the list of all the raw CLI parameters args because that's the convention with Click. But it doesn't contain only CLI arguments , it has everything, including CLI options and values, as a raw list of str . And then we just print it to "standard error". $ typer ./main.py run --name [ TAB ][ TAB ] // First we see the raw CLI parameters ['./main.py', 'run', '--name'] // And then we see the actual completion Camila     -- The reader of books. Carlos     -- The writer of scripts. Sebastian  -- The type hints guy. Tip This is a very simple (and quite useless) example, just so you know how it works and that you can use it. But it's probably useful only in very advanced use cases. Getting the Context and the raw CLI parameters ¬∂ Of course, you can declare everything if you need it, the context, the raw CLI parameters , and the incomplete str : Python 3.6+ Python 3.6+ non-Annotated from typing import List import typer from rich.console import Console from typing_extensions import Annotated valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] err_console = Console ( stderr = True ) def complete_name ( ctx : typer . Context , args : List [ str ], incomplete : str ): err_console . print ( f " { args } " ) names = ctx . params . get ( "name" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : Annotated [ List [ str ], typer . Option ( help = "The name to say hi to." , autocompletion = complete_name ), ] = [ "World" ], ): for n in name : print ( f "Hello { n } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. from typing import List import typer from rich.console import Console valid_completion_items = [ ( "Camila" , "The reader of books." ), ( "Carlos" , "The writer of scripts." ), ( "Sebastian" , "The type hints guy." ), ] err_console = Console ( stderr = True ) def complete_name ( ctx : typer . Context , args : List [ str ], incomplete : str ): err_console . print ( f " { args } " ) names = ctx . params . get ( "name" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) app = typer . Typer () @app . command () def main ( name : List [ str ] = typer . Option ( [ "World" ], help = "The name to say hi to." , autocompletion = complete_name ) ): for n in name : print ( f "Hello { n } " ) if __name__ == "__main__" : app () Check it: $ typer ./main.py run --name [ TAB ][ TAB ] // First we see the raw CLI parameters ['./main.py', 'run', '--name'] // And then we see the actual completion Camila     -- The reader of books. Carlos     -- The writer of scripts. Sebastian  -- The type hints guy. $ typer ./main.py run --name Sebastian --name Ca [ TAB ][ TAB ] // Again, we see the raw CLI parameters ['./main.py', 'run', '--name', 'Sebastian', '--name'] // And then we see the rest of the valid completion items Camila     -- The reader of books. Carlos     -- The writer of scripts. Types, types everywhere ¬∂ Typer uses the type declarations to detect what it has to provide to your autocompletion function. You can declare function parameters of these types: str : for the incomplete value. typer.Context : for the current context. List[str] : for the raw CLI parameters . It doesn't matter how you name them, in which order, or which ones of the 3 options you declare. It will all " just work " ‚ú® Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Progress Bar - Typer Skip to content Typer Progress Bar Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar Progress Bar Table of contents Progress Bar Spinner Typer progressbar Use typer.progressbar Setting a Progress Bar length About the function with yield Add a label Iterate manually CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Progress Bar Spinner Typer progressbar Use typer.progressbar Setting a Progress Bar length About the function with yield Add a label Iterate manually Progress Bar If you are executing an operation that can take some time, you can inform it to the user. ü§ì Progress Bar ¬∂ You can use Rich's Progress Display to show a progress bar, for example: import time import typer from rich.progress import track def main (): total = 0 for value in track ( range ( 100 ), description = "Processing..." ): # Fake processing time time . sleep ( 0.01 ) total += 1 print ( f "Processed { total } things." ) if __name__ == "__main__" : typer . run ( main ) You put the thing that you want to iterate over inside of Rich's track() , and then iterate over that. Check it: $ python main.py ---> 100% Processed 100 things. ...actually, it will look a lot prettier. ‚ú® But I can't show you the animation here in the docs. üòÖ The colors and information will look something like this: $ python main.py Processing... <font color="#F92672">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ï∏</font><font color="#3A3A3A">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</font> <font color="#AE81FF"> 74%</font> <font color="#A1EFE4">0:00:01</font> Spinner ¬∂ When you don't know how long the operation will take, you can use a spinner instead. Rich allows you to display many things in complex and advanced ways. For example, this will show two spinners: import time import typer from rich.progress import Progress , SpinnerColumn , TextColumn def main (): with Progress ( SpinnerColumn (), TextColumn ( "[progress.description] {task.description} " ), transient = True , ) as progress : progress . add_task ( description = "Processing..." , total = None ) progress . add_task ( description = "Preparing..." , total = None ) time . sleep ( 5 ) print ( "Done!" ) if __name__ == "__main__" : typer . run ( main ) I can't show you the beautiful animation here in the docs. üòÖ But at some point in time it will look like this (imagine it's spinning). ü§ì $ python main.py <font color="#A6E22E">‚†π</font> Processing... <font color="#A6E22E">‚†π</font> Preparing... You can learn more about it in the Rich docs for Progress Display . Typer progressbar ¬∂ If you can, you should use Rich as explained above, it has more features, it's more advanced, and can display information more beautifully. ‚ú® Tip If you can use Rich, use the information above, the Rich docs, and skip the rest of this page. üòé But if you can't use Rich, Typer (actually Click) comes with a simple utility to show progress bars. Info typer.progressbar() comes directly from Click, you can read more about it in Click's docs . Use typer.progressbar ¬∂ Tip Remember, you are much better off using Rich for this. üòé You can use typer.progressbar() with a with statement, as in: with typer . progressbar ( something ) as progress : pass And you pass as function argument to typer.progressbar() the thing that you would normally iterate over. import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 )) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 print ( f "Processed { total } things." ) if __name__ == "__main__" : typer . run ( main ) So, if you have a list of users, this could be: users = [ "Camila" , "Rick" , "Morty" ] with typer . progressbar ( users ) as progress : pass And the with statement using typer.progressbar() gives you an object that you can iterate over, just like if it was the same thing that you would iterate over normally. But by iterating over this object Typer (actually Click) will know to update the progress bar: users = [ "Camila" , "Rick" , "Morty" ] with typer . progressbar ( users ) as progress : for user in progress : typer . echo ( user ) Tip Notice that there are 2 levels of code blocks. One for the with statement and one for the for statement. Info This is mostly useful for operations that take some time. In the example above we are faking it with time.sleep() . Check it: $ python main.py ---> 100% Processed 100 things. Setting a Progress Bar length ¬∂ Tip Remember, you are much better off using Rich for this. üòé The progress bar is generated from the length of the iterable (e.g. the list of users). But if the length is not available (for example, with something that fetches a new user from a web API each time) you can pass an explicit length to typer.progressbar() . import time import typer def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i def main (): total = 0 with typer . progressbar ( iterate_user_ids (), length = 100 ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 print ( f "Processed { total } user IDs." ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py ---> 100% Processed 100 user IDs. About the function with yield ¬∂ If you hadn't seen something like that yield above, that's a " generator ". You can iterate over that function with a for and at each iteration it will give you the value at yield . yield is like a return that gives values multiple times and let's you use the function in a for loop. For example: def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i for i in iterate_user_ids (): print ( i ) would print each of the "user IDs" (here it's just the numbers from 0 to 99 ). Add a label ¬∂ Tip Remember, you are much better off using Rich for this. üòé You can also set a label : import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 ), label = "Processing" ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 print ( f "Processed { total } things." ) if __name__ == "__main__" : typer . run ( main ) Check it: python main.py Processed 100 things. Iterate manually ¬∂ If you need to manually iterate over something and update the progress bar irregularly, you can do it by not passing an iterable but just a length to typer.progressbar() . And then calling the .update() method in the object from the with statement: import time import typer def main (): total = 1000 with typer . progressbar ( length = total ) as progress : for batch in range ( 4 ): # Fake processing time time . sleep ( 1 ) progress . update ( 250 ) print ( f "Processed { total } things in batches." ) if __name__ == "__main__" : typer . run ( main ) Check it: python main.py Processed 100 things in batches. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Exceptions and Errors - Typer Skip to content Typer Exceptions and Errors Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Exceptions and Errors Table of contents Example Broken App Exceptions with Rich Exceptions without Rich Disable Local Variables for Security Disable Short Output Disable Pretty Exceptions Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Example Broken App Exceptions with Rich Exceptions without Rich Disable Local Variables for Security Disable Short Output Disable Pretty Exceptions Exceptions and Errors ¬∂ When your code has errors and you run it, it will show the error and an exception. Typer does some tricks to help you detect those errors quickly. Example Broken App ¬∂ Let's take this example broken app: import typer def main ( name : str = "morty" ): print ( name + 3 ) if __name__ == "__main__" : typer . run ( main ) This code is broken because you can't sum a string and a number ( name + 3 ). Exceptions with Rich ¬∂ If you have Rich installed (for example if you installed "typer[all]" ), Typer will use it to automatically show you nicely printed errors. It will omit all the parts of the traceback (the chain of things that called your function) that come from the internal parts in Typer and Click. So, the error you see will be much clearer and simpler, to help you detect the problem in your code quickly: $ python main.py <font color="#F92672">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ </font><font color="#F92672"><b>Traceback (most recent call last)</b></font><font color="#F92672"> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/</font><font color="#F4BF75"><b>main.py</b></font>:<font color="#66D9EF">5</font> in <font color="#A6E22E">main</font>                        <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    2                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    3                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    4 <font color="#66D9EF">def</font> <font color="#A6E22E">main</font>(name: <font color="#A1EFE4">str</font> = <font color="#F4BF75">&quot;morty&quot;</font>):                               <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ù± </font> 5 ‚îÇ   <font color="#A1EFE4">print</font>(name + <font color="#66D9EF">3</font>)                                          <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    6                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    7                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    8 <font color="#66D9EF">if</font> <font color="#F92672">__name__</font> == <font color="#F4BF75">&quot;__main__&quot;</font>:                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ locals ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font>                                                <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font> name = <font color="#F4BF75">&apos;morty&apos;</font> <font color="#F4BF75">‚îÇ</font>                                                <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font>                                                <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#F92672"><b>TypeError: </b></font>can only concatenate str <b>(</b>not <font color="#A6E22E">&quot;int&quot;</font><b>)</b> to str Exceptions without Rich ¬∂ If you don't have Rich installed, Typer will still do some tricks to show you the information as clearly as possible : $ python main.py Traceback (most recent call last): File "main.py", line 12, in <module> typer.run(main) File "main.py", line 8, in main print(name + 3) TypeError: can only concatenate str (not "int") to str Disable Local Variables for Security ¬∂ If your Typer application handles delicate information , for example a password , a key , a token , then it could be problematic if the automatic errors show the value in those local variables . This would be relevant in particular if your CLI application is being run on some CI (continuous integration) system that is recording the logs. The default errors above, when using Rich, show a section with: name = 'morty' In this case, name is a local variable, it comes from a parameter passed to the function. But if it was something like a password, would would have liked to hide it. In that case, you can create the typer.Typer() application explicitly and set the parameter pretty_exceptions_show_locals=False : import typer app = typer . Typer ( pretty_exceptions_show_locals = False ) @app . command () def main ( password : str ): print ( password + 3 ) if __name__ == "__main__" : app () And now when you run it, you will see the error without the local variables: $ python main.py supersecret <font color="#F92672">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ </font><font color="#F92672"><b>Traceback (most recent call last)</b></font><font color="#F92672"> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/</font><font color="#F4BF75"><b>main.py</b></font>:<font color="#66D9EF">8</font> in <font color="#A6E22E">main</font>                        <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    5                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    6 <font color="#AE81FF"><b>@app</b></font>.command()                                               <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    7 <font color="#66D9EF">def</font> <font color="#A6E22E">main</font>(password: <font color="#A1EFE4">str</font>):                                     <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ù± </font> 8 ‚îÇ   <font color="#A1EFE4">print</font>(password + <font color="#66D9EF">3</font>)                                      <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    9                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>   10                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>   11 <font color="#66D9EF">if</font> <font color="#F92672">__name__</font> == <font color="#F4BF75">&quot;__main__&quot;</font>:                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#F92672"><b>TypeError: </b></font>can only concatenate str <b>(</b>not <font color="#A6E22E">&quot;int&quot;</font><b>)</b> to str Note that you passed the password supersecret , but it's not shown anywhere in the error message. Being able to see the values of local variables is normally very helpful to diagnose, debug , and fix problems, but if you are dealing with delicate information, now you know how to secure it. üîí Disable Short Output ¬∂ If you want to show the full exception, including the parts in Typer and Click, you can use the parameter pretty_exceptions_short=False : import typer app = typer . Typer ( pretty_exceptions_short = False ) @app . command () def main ( name : str = "morty" ): print ( name + 3 ) if __name__ == "__main__" : app () Now when you run it, you will see the whole output: $ python main.py <font color="#F92672">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ </font><font color="#F92672"><b>Traceback (most recent call last)</b></font><font color="#F92672"> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/</font><font color="#F4BF75"><b>main.py</b></font>:<font color="#66D9EF">12</font> in <font color="#A6E22E">&lt;module&gt;</font>                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    9                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>   10                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>   11 <font color="#66D9EF">if</font> <font color="#F92672">__name__</font> == <font color="#F4BF75">&quot;__main__&quot;</font>:                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ù± </font>12 ‚îÇ   app()                                                    <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>   13                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ locals ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font> <font color="#A6194C">__annotations__</font> = <b>{}</b>                                          <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>    <font color="#A6194C">__builtins__</font> = <b>&lt;</b><font color="#AE81FF"><b>module</b></font> <font color="#F4BF75">&apos;builtins&apos;</font> <b>(</b>built-in<b>)&gt;</b>              <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>      <font color="#A6194C">__cached__</font> = <font color="#66D9EF">None</font>                                        <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>         <font color="#A6194C">__doc__</font> = <font color="#66D9EF">None</font>                                        <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>        <font color="#A6194C">__file__</font> = <font color="#F4BF75">&apos;main.py&apos;</font>                                   <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>      <font color="#A6194C">__loader__</font> = <b>&lt;</b><font color="#AE81FF"><b>_frozen_importlib_external.SourceFileLoad‚Ä¶</b></font> <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>                   object at <font color="#66D9EF">0x7f047db1c050</font><b>&gt;</b>                   <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>        <font color="#A6194C">__name__</font> = <font color="#F4BF75">&apos;__main__&apos;</font>                                  <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>     <font color="#A6194C">__package__</font> = <font color="#66D9EF">None</font>                                        <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>        <font color="#A6194C">__spec__</font> = <font color="#66D9EF">None</font>                                        <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>             app = <b>&lt;</b><font color="#AE81FF"><b>typer.main.Typer</b></font> object at <font color="#66D9EF">0x7f047db51d90</font><b>&gt;</b> <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>            main = <b>&lt;</b><font color="#AE81FF"><b>function</b></font> main at <font color="#66D9EF">0x7f047db56830</font><b>&gt;</b>           <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>           typer = <b>&lt;</b><font color="#AE81FF"><b>module</b></font> <font color="#F4BF75">&apos;typer&apos;</font> from                        <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font>                   <font color="#F4BF75">&apos;/home/user/code/superapp/env/lib/python3.‚Ä¶</font> <font color="#F4BF75">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/typer/</font><font color="#F4BF75"><b>ma</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>in.py</b></font>:<font color="#66D9EF">328</font> in <font color="#A6E22E">__call__</font>                                             <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/typer/</font><font color="#F4BF75"><b>ma</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>in.py</b></font>:<font color="#66D9EF">311</font> in <font color="#A6E22E">__call__</font>                                             <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/click/</font><font color="#F4BF75"><b>co</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>re.py</b></font>:<font color="#66D9EF">1130</font> in <font color="#A6E22E">__call__</font>                                            <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/typer/</font><font color="#F4BF75"><b>co</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>re.py</b></font>:<font color="#66D9EF">723</font> in <font color="#A6E22E">main</font>                                                 <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/typer/</font><font color="#F4BF75"><b>co</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>re.py</b></font>:<font color="#66D9EF">216</font> in <font color="#A6E22E">_main</font>                                                <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/click/</font><font color="#F4BF75"><b>co</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>re.py</b></font>:<font color="#66D9EF">1404</font> in <font color="#A6E22E">invoke</font>                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/click/</font><font color="#F4BF75"><b>co</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>re.py</b></font>:<font color="#66D9EF">760</font> in <font color="#A6E22E">invoke</font>                                               <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/env/lib/python3.7/site-packages/typer/</font><font color="#F4BF75"><b>ma</b></font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75"><b>in.py</b></font>:<font color="#66D9EF">683</font> in <font color="#A6E22E">wrapper</font>                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#A37F4E">/home/user/code/superapp/</font><font color="#F4BF75"><b>main.py</b></font>:<font color="#66D9EF">8</font> in <font color="#A6E22E">main</font>                        <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    5                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    6 <font color="#AE81FF"><b>@app</b></font>.command()                                               <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    7 <font color="#66D9EF">def</font> <font color="#A6E22E">main</font>(name: <font color="#A1EFE4">str</font> = <font color="#F4BF75">&quot;morty&quot;</font>):                               <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ù± </font> 8 ‚îÇ   <font color="#A1EFE4">print</font>(name + <font color="#66D9EF">3</font>)                                          <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>    9                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>   10                                                              <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>   11 <font color="#66D9EF">if</font> <font color="#F92672">__name__</font> == <font color="#F4BF75">&quot;__main__&quot;</font>:                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font>                                                                   <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ locals ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font>                                                <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚îÇ</font> name = <font color="#F4BF75">&apos;morty&apos;</font> <font color="#F4BF75">‚îÇ</font>                                                <font color="#F92672">‚îÇ</font> <font color="#F92672">‚îÇ</font> <font color="#F4BF75">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font>                                                <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#F92672"><b>TypeError: </b></font>can only concatenate str <b>(</b>not <font color="#A6E22E">&quot;int&quot;</font><b>)</b> to str Disable Pretty Exceptions ¬∂ You can also entirely disable pretty exceptions with the parameter pretty_exceptions_enable=False : import typer app = typer . Typer ( pretty_exceptions_enable = False ) @app . command () def main ( name : str = "morty" ): print ( name + 3 ) if __name__ == "__main__" : app () And now you will see the full standard exception as with any other Python program: $ python main.py Traceback (most recent call last): File "main.py", line 12, in <module> app() File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py", line 328, in __call__ raise e File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py", line 311, in __call__ return get_command(self)(*args, **kwargs) File "/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py", line 1130, in __call__ return self.main(*args, **kwargs) File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py", line 723, in main **extra, File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py", line 216, in _main rv = self.invoke(ctx) File "/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py", line 1404, in invoke return ctx.invoke(self.callback, **ctx.params) File "/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py", line 760, in invoke return __callback(*args, **kwargs) File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py", line 683, in wrapper return callback(**use_params)  # type: ignore File "main.py", line 8, in main print(name + 3) TypeError: can only concatenate str (not "int") to str You could also achieve the same with the environment variable _TYPER_STANDARD_TRACEBACK=1 . This will work for any other Typer program too, in case you need to debug a problem in a Typer program made by someone else: export _TYPER_STANDARD_TRACEBACK=1 $ python main.py Traceback (most recent call last): File "main.py", line 12, in <module> app() File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py", line 328, in __call__ raise e File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py", line 311, in __call__ return get_command(self)(*args, **kwargs) File "/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py", line 1130, in __call__ return self.main(*args, **kwargs) File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py", line 723, in main **extra, File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py", line 216, in _main rv = self.invoke(ctx) File "/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py", line 1404, in invoke return ctx.invoke(self.callback, **ctx.params) File "/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py", line 760, in invoke return __callback(*args, **kwargs) File "/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py", line 683, in wrapper return callback(**use_params)  # type: ignore File "main.py", line 8, in main print(name + 3) TypeError: can only concatenate str (not "int") to str Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Testing - Typer Skip to content Typer Testing Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Testing Table of contents Test the app Import and create a CliRunner Call the app Check the result Call pytest Testing input Test a function About the app.command decorator Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Test the app Import and create a CliRunner Call the app Check the result Call pytest Testing input Test a function About the app.command decorator Testing Testing Typer applications is very easy with pytest . Let's say you have an application app/main.py with: from typing import Optional import typer app = typer . Typer () @app . command () def main ( name : str , city : Optional [ str ] = None ): print ( f "Hello { name } " ) if city : print ( f "Let's have a coffee in { city } " ) if __name__ == "__main__" : app () So, you would use it like: $ python main.py Camila --city Berlin Hello Camila Let's have a coffee in Berlin And the directory also has an empty app/__init__.py file. So, the app is a "Python package". Test the app ¬∂ Import and create a CliRunner ¬∂ Create another file/module app/test_main.py . Import CliRunner and create a runner object. This runner is what will "invoke" or "call" your command line application. from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ "Camila" , "--city" , "Berlin" ]) assert result . exit_code == 0 assert "Hello Camila" in result . stdout assert "Let's have a coffee in Berlin" in result . stdout Tip It's important that the name of the file starts with test_ , that way pytest will be able to detect it and use it automatically. Call the app ¬∂ Then create a function test_app() . And inside of the function, use the runner to invoke the application. The first parameter to runner.invoke() is a Typer app. The second parameter is a list of str , with all the text you would pass in the command line, right as you would pass it: from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ "Camila" , "--city" , "Berlin" ]) assert result . exit_code == 0 assert "Hello Camila" in result . stdout assert "Let's have a coffee in Berlin" in result . stdout Tip The name of the function has to start with test_ , that way pytest can detect it and use it automatically. Check the result ¬∂ Then, inside of the test function, add assert statements to ensure that everything in the result of the call is as it should be. from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ "Camila" , "--city" , "Berlin" ]) assert result . exit_code == 0 assert "Hello Camila" in result . stdout assert "Let's have a coffee in Berlin" in result . stdout Here we are checking that the exit code is 0, as it is for programs that exit without errors. Then we check that the text printed to "standard output" contains the text that our CLI program prints. Tip You could also check result.stderr for "standard error" independently from "standard output" if your CliRunner instance is created with the mix_stderr=False argument. Info If you need a refresher about what is "standard output" and "standard error" check the section in Printing and Colors: "Standard Output" and "Standard Error" . Call pytest ¬∂ Then you can call pytest in your directory and it will run your tests: $ pytest ================ test session starts ================ platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1 rootdir: /home/user/code/superawesome-cli/app plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1 collected 1 item ---> 100% test_main.py <span style="color: green; white-space: pre;">.                                 [100%]</span> <span style="color: green;">================= 1 passed in 0.03s =================</span> Testing input ¬∂ If you have a CLI with prompts, like: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated app = typer . Typer () @app . command () def main ( name : str , email : Annotated [ str , typer . Option ( prompt = True )]): print ( f "Hello { name } , your email is: { email } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer () @app . command () def main ( name : str , email : str = typer . Option ( ... , prompt = True )): print ( f "Hello { name } , your email is: { email } " ) if __name__ == "__main__" : app () That you would use like: $ python main.py Camila # Email: $ camila@example.com Hello Camila, your email is: camila@example.com You can test the input typed in the terminal using input="camila@example.com\n" . This is because what you type in the terminal goes to " standard input " and is handled by the operating system as if it was a "virtual file". Info If you need a refresher about what is "standard output", "standard error", and "standard input" check the section in Printing and Colors: "Standard Output" and "Standard Error" . When you hit the ENTER key after typing the email, that is just a "new line character". And in Python that is represented with "\n" . So, if you use input="camila@example.com\n" it means: "type camila@example.com in the terminal, then hit the ENTER key": from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ "Camila" ], input = "camila@example.com \n " ) assert result . exit_code == 0 assert "Hello Camila, your email is: camila@example.com" in result . stdout Test a function ¬∂ If you have a script and you never created an explicit typer.Typer app, like: import typer def main ( name : str = "World" ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) ...you can still test it, by creating an app during testing: import typer from typer.testing import CliRunner from .main import main app = typer . Typer () app . command ()( main ) runner = CliRunner () def test_app (): result = runner . invoke ( app , [ "--name" , "Camila" ]) assert result . exit_code == 0 assert "Hello Camila" in result . stdout Of course, if you are testing that script, it's probably easier/cleaner to just create the explicit typer.Typer app in main.py instead of creating it just during the test. But if you want to keep it that way, e.g. because it's a simple example in documentation, then you can use that trick. About the app.command decorator ¬∂ Notice the app.command()(main) . If it's not obvious what it's doing, continue reading... You would normally write something like: @app . command () def main ( name : str = "World" ): # Some code here But @app.command() is just a decorator. That's equivalent to: def main ( name : str = "World" ): # Some code here decorator = app . command () new_main = decorator ( main ) main = new_main app.command() returns a function ( decorator ) that takes another function as it's only parameter ( main ). And by using the @something you normally tell Python to replace the thing below (the function main ) with the return of the decorator function ( new_main ). Now, in the specific case of Typer , the decorator doesn't change the original function. It registers it internally and returns it unmodified. So, new_main is actually the same original main . So, in the case of Typer , as it doesn't really modify the decorated function, that would be equivalent to: def main ( name : str = "World" ): # Some code here decorator = app . command () decorator ( main ) But then we don't need to create the variable decorator to use it below, we can just use it directly: def main ( name : str = "World" ): # Some code here app . command ()( main ) ...that's it. It's still probably simpler to just create the explicit typer.Typer in the main.py file üòÖ. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

First Steps - Typer Skip to content Typer First Steps Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps First Steps Table of contents The simplest example What is a CLI argument Add a CLI argument Two CLI arguments What is a CLI option Add one CLI option A CLI option with a value Document your CLI app Arguments, options, parameters, optional, required In Python Python default values In CLIs In Typer Typer CLI Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents The simplest example What is a CLI argument Add a CLI argument Two CLI arguments What is a CLI option Add one CLI option A CLI option with a value Document your CLI app Arguments, options, parameters, optional, required In Python Python default values In CLIs In Typer Typer CLI First Steps The simplest example ¬∂ The simplest Typer file could look like this: import typer def main (): print ( "Hello World" ) if __name__ == "__main__" : typer . run ( main ) Copy that to a file main.py . Test it: $ python main.py Hello World // It just prints "Hello World". // Now check the --help $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS]                            </b> <b>                                                     </b> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                        Show this message   ‚îÇ <font color="#A5A5A1">‚îÇ                               and exit.           ‚îÇ</font> <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> ...but this program is still not very useful. Let's extend it. What is a CLI argument ¬∂ Here we will use the word CLI argument to refer to CLI parameters passed in some specific order to the CLI application. By default, they are required . If you go to your terminal and type: $ ls ./myproject

first-steps.md intro.md ls will show the contents of the directory ./myproject . ls is the program (or "command", "CLI app"). ./myproject is a CLI argument , in this case it refers to the path of a directory. They are a bit different from CLI options that you will see later below. Add a CLI argument ¬∂ Update the previous example with an argument name : import typer def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) $ python main.py // If you run it without the argument, it shows a nice error <font color="#F4BF75">Usage: </font>main.py [OPTIONS] NAME <font color="#A5A5A1">Try </font><font color="#44919F">&apos;main.py </font><font color="#44919F"><b>--help</b></font><font color="#44919F">&apos;</font><font color="#A5A5A1"> for help.</font> <font color="#F92672">‚ï≠‚îÄ Error ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> Missing argument &apos;NAME&apos;.                          <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> // Now pass that NAME CLI argument $ python main.py Camila Hello Camila // Here "Camila" is the CLI argument // To pass a name with spaces for the same CLI argument, use quotes $ python main.py "Camila Guti√©rrez" Hello Camila Guti√©rrez Tip If you need to pass a single value that contains spaces to a CLI argument , use quotes ( " ) around it. Two CLI arguments ¬∂ Now let's say we want to have the name and last name separated. So, extend that to have 2 arguments, name and lastname : import typer def main ( name : str , lastname : str ): print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) // Check the main --help $ python main.py --help <font color="#F4BF75">Usage: </font>main.py [OPTIONS] NAME <font color="#A5A5A1">Try </font><font color="#44919F">&apos;main.py </font><font color="#44919F"><b>--help</b></font><font color="#44919F">&apos;</font><font color="#A5A5A1"> for help.</font> <font color="#F92672">‚ï≠‚îÄ Error ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> Missing argument &apos;NAME&apos;.                          <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A1EFE4"><b>typer</b></font> on <font color="#AE81FF"><b>ÓÇ† richify</b></font> <font color="#F92672"><b>[¬ª!?] </b></font>via <font color="#F4BF75"><b>üêç v3.7.5 (env3.7)</b></font> <font color="#F92672"><b>‚ùØ</b></font> <font color="#A6E22E">python</font> <u style="text-decoration-style:single">main.py</u> <font color="#F4BF75">Usage: </font>main.py [OPTIONS] NAME LASTNAME <font color="#A5A5A1">Try </font><font color="#44919F">&apos;main.py </font><font color="#44919F"><b>--help</b></font><font color="#44919F">&apos;</font><font color="#A5A5A1"> for help.</font> <font color="#F92672">‚ï≠‚îÄ Error ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> Missing argument &apos;NAME&apos;.                          <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> // There are now 2 CLI arguments, name and lastname // Now pass a single name argument $ python main.py Camila <font color="#F4BF75">Usage: </font>main.py [OPTIONS] NAME LASTNAME <font color="#A5A5A1">Try </font><font color="#44919F">&apos;main.py </font><font color="#44919F"><b>--help</b></font><font color="#44919F">&apos;</font><font color="#A5A5A1"> for help.</font> <font color="#F92672">‚ï≠‚îÄ Error ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#F92672">‚îÇ</font> Missing argument &apos;LASTNAME&apos;.                      <font color="#F92672">‚îÇ</font> <font color="#F92672">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> // These 2 arguments are required, so, pass both: $ python main.py Camila Guti√©rrez Hello Camila Guti√©rrez Tip Notice that the order is important. The last name has to go after the first name. If you called it with: $ python main.py Guti√©rrez Camila your app wouldn't have a way to know which is the name and which the lastname . It expects the first CLI argument to be the name and the second CLI argument to be the lastname . What is a CLI option ¬∂ Here we will use the word CLI option to refer to CLI parameters passed to the CLI application with a specific name. For example, if you go to your terminal and type: $ ls ./myproject --size 12 first-steps.md   4 intro.md ls will show the contents of the directory ./myproject with their size . ls is the program (or "command", "CLI app"). ./myproject is a CLI argument . --size is an optional CLI option . The program knows it has to show the size because it sees --size , not because of the order. A CLI option like --size doesn't depend on the order like a CLI argument . So, if you put the --size before the CLI argument , it still works (in fact, that's the most common way of doing it): $ ls --size ./myproject 12 first-steps.md   4 intro.md The main visual difference between a CLI option and a CLI argument is that the CLI option has -- prepended to the name, like in " --size ". A CLI option doesn't depend on the order because it has a predefined name (here it's --size ). This is because the CLI app is looking specifically for a literal --size parameter (also known as "flag" or "switch"), with that specific "name" (here the specific name is " --size "). The CLI app will check if you typed it or not, it will be actively looking for --size even if you didn't type it (to check if it's there or not). In contrast, the CLI app is not actively looking for the CLI argument with a text " ./myproject ", it has no way to know if you would type ./myproject or ./my-super-awesome-project or anything else. It's just waiting to get whatever you give it. The only way to know that you refer to a specific CLI argument is because of the order. The same way that it knows that the first CLI argument was the name and the second was the lastname , but if you mixed the order, it wouldn't be able to handle it. Instead, with a CLI option , the order doesn't matter. Also, by default, a CLI option is optional (not required ). So, by default: A CLI argument is required A CLI option is optional But the required and optional defaults can be changed. So, the main and most important difference is that: CLI options start with -- and don't depend on the order CLI arguments depend on the sequence order Tip In this example above the CLI option --size is just a "flag" or "switch" that will contain a boolean value, True or False , depending on if it was added to the command or not. This one doesn't receive any values. But CLI options can also receive values like CLI arguments . You'll see how later. Add one CLI option ¬∂ Now add a --formal CLI option : import typer def main ( name : str , lastname : str , formal : bool = False ): if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Here formal is a bool that is False by default. // Get the help $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] NAME LASTNAME                            </b> <b>                                                                   </b> <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    name          <font color="#F4BF75"><b>TEXT</b></font>  [default: None] <font color="#A6194C">[required]</font>             ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    lastname      <font color="#F4BF75"><b>TEXT</b></font>  [default: None] <font color="#A6194C">[required]</font>             ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--formal</b></font>                <font color="#AE81FF"><b>--no-formal</b></font>      [default: no-formal]   ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                                   Show this message and  ‚îÇ <font color="#A5A5A1">‚îÇ                                          exit.                  ‚îÇ</font> <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Tip Notice that it automatically creates a --formal and a --no-formal because it detected that formal is a bool . Now call it normally: $ python main.py Camila Guti√©rrez Hello Camila Guti√©rrez // But if you pass --formal $ python main.py Camila Guti√©rrez --formal Good day Ms. Camila Guti√©rrez. // And as --formal is a CLI option you can put it anywhere in this command $ python main.py Camila --formal Guti√©rrez Good day Ms. Camila Guti√©rrez. $ python main.py --formal Camila Guti√©rrez Good day Ms. Camila Guti√©rrez. A CLI option with a value ¬∂ To convert the lastname from a CLI argument to a CLI option , give it a default value of "" : import typer def main ( name : str , lastname : str = "" , formal : bool = False ): if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) As lastname now has a default value of "" (an empty string) it is no longer required in the function, and Typer will now by default make it an optional CLI option . $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] NAME                                       </b> <b>                                                                     </b> <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    name      <font color="#F4BF75"><b>TEXT</b></font>  [default: None] <font color="#A6194C">[required]</font>                   ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--lastname</b></font>                             <font color="#F4BF75"><b>TEXT</b></font>                       ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--formal</b></font>                <font color="#AE81FF"><b>--no-formal</b></font>    <font color="#F4BF75"><b>    </b></font>  [default: no-formal] ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                                 <font color="#F4BF75"><b>    </b></font>  Show this message    ‚îÇ <font color="#A5A5A1">‚îÇ                                              and exit.            ‚îÇ</font> <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Tip Notice the --lastname , and notice that it takes a textual value. A CLI option with a value like --lastname (contrary to a CLI option without a value, a bool flag, like --formal or --size ) takes as its value whatever is at the right side of the CLI option . // Call it without a --lastname $ python main.py Camila Hello Camila // Pass the --lastname $ python main.py Camila --lastname Guti√©rrez Hello Camila Guti√©rrez Tip Notice that " Guti√©rrez " is at the right side of --lastname . A CLI option with a value takes as its value whatever is at the right side . And as --lastname is now a CLI option that doesn't depend on the order, you can pass it before the name: $ python main.py --lastname Guti√©rrez Camila // and it will still work normally Hello Camila Guti√©rrez Document your CLI app ¬∂ If you add a docstring to your function it will be used in the help text: import typer def main ( name : str , lastname : str = "" , formal : bool = False ): """ Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. """ if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Now see it with the --help option: $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] NAME                                       </b> <b>                                                                     </b> Say hi to NAME, optionally with a <font color="#A1EFE4"><b>--lastname</b></font>. If <font color="#6B9F98"><b>--formal</b></font><font color="#A5A5A1"> is used, say hi very formally.                          </font> <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    name      <font color="#F4BF75"><b>TEXT</b></font>  [default: None] <font color="#A6194C">[required]</font>                   ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--lastname</b></font>                             <font color="#F4BF75"><b>TEXT</b></font>                       ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--formal</b></font>                <font color="#AE81FF"><b>--no-formal</b></font>    <font color="#F4BF75"><b>    </b></font>  [default: no-formal] ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                                 <font color="#F4BF75"><b>    </b></font>  Show this message    ‚îÇ <font color="#A5A5A1">‚îÇ                                              and exit.            ‚îÇ</font> <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Tip There is another place to document the specific CLI options and CLI arguments that will show up next to them in the help text as with --install-completion or --help , you will learn that later in the tutorial. Arguments, options, parameters, optional, required ¬∂ Be aware that these terms refer to multiple things depending on the context, and sadly, those "contexts" mix frequently, so it's easy to get confused. In Python ¬∂ In Python, the names of the variables in a function, like name and lastname : def main ( name : str , lastname : str = "" ): pass are called "Python function parameters" or "Python function arguments". Technical Details There's actually a very small distinction in Python between "parameter" and "argument". It's quite technical... and somewhat pedantic. Parameter refers to the variable name in a function declaration . Like: def bring_person(name: str, lastname: str = ""):
    pass Argument refers to the value passed when calling a function. Like: person = bring_person("Camila", lastname="Guti√©rrez") ...but you will probably see them used interchangeably in most of the places (including here). Python default values ¬∂ In Python, in a function, a parameter with a default value like lastname in: def main ( name : str , lastname : str = "" ): pass is considered an "optional parameter" (or "optional argument"). The default value can be anything, like "" or None . And a parameter like name , that doesn't have a default value, is considered required . In CLIs ¬∂ When talking about command line interface applications, the words "argument" and "parameter" are commonly used to refer to that data passed to a CLI app, those parameters. But those words don't imply anything about the data being required, needing to be passed in a certain order, nor having a flag like --lastname . The parameters that come with a name like --lastname (and optionally a value) are commonly optional, not required. So, when talking about CLIs it's common to call them optional arguments or optional parameters . Sometimes these optional parameters that start with -- are also called a flag or a switch . In reality, the parameters that require an order can be made optional too. And the ones that come with a flag (like --lastname ) can be required too. In Typer ¬∂ To try and make it a bit easier, we'll normally use the words "parameter" or "argument" to refer to Python functions. We'll use CLI argument to refer to those CLI parameters that depend on the specific order. That are required by default. And we'll use CLI option to refer to those CLI parameters that depend on a name that starts with -- (like --lastname ). That are optional by default. We will use CLI parameter to refer to both, CLI arguments and CLI options . Typer CLI ¬∂ Now that you know the basics of Typer , you might want to install and use Typer CLI . Typer CLI is a tool to run your Typer scripts giving you ‚ú® auto completion ‚ú® in your terminal. As an alternative to running with Python: $ python main.py Hello World You can run with Typer CLI : $ typer main.py run Hello World ...and it will give you auto completion in your terminal when you hit TAB for all your code. So you can use it to have auto completion for your own scripts as you continue with the tutorial. Tip Your CLI application built with Typer won't need Typer CLI to have auto completion once you create a Python package. But for short scripts and for learning, before creating a Python package, it might be useful. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Ask with Prompt - Typer Skip to content Typer Ask with Prompt Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Ask with Prompt Table of contents Confirm Confirm or abort Prompt with Rich Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Confirm Confirm or abort Prompt with Rich Ask with Prompt When you need to ask the user for info interactively you should normally use CLI Option s with Prompt , because they allow using the CLI program in a non-interactive way (for example, a Bash script could use it). But if you absolutely need to ask for interactive information without using a CLI option , you can use typer.prompt() : import typer def main (): person_name = typer . prompt ( "What's your name?" ) print ( f "Hello { person_name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py # What ' s your name?:$ Camila Hello Camila Confirm ¬∂ There's also an alternative to ask for confirmation. Again, if possible, you should use a CLI Option with a confirmation prompt : import typer def main (): delete = typer . confirm ( "Are you sure you want to delete it?" ) if not delete : print ( "Not deleting" ) raise typer . Abort () print ( "Deleting it!" ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Not deleting Aborted! Confirm or abort ¬∂ As it's very common to abort if the user doesn't confirm, there's an integrated parameter abort that does it automatically: import typer def main (): delete = typer . confirm ( "Are you sure you want to delete it?" , abort = True ) print ( "Deleting it!" ) if __name__ == "__main__" : typer . run ( main ) $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Aborted! Prompt with Rich ¬∂ If you installed Rich as described in Printing and Colors , you can use Rich to prompt the user for input: import typer from rich.prompt import Prompt def main (): name = Prompt . ask ( "Enter your name :sunglasses:" ) print ( f "Hey there { name } !" ) if __name__ == "__main__" : typer . run ( main ) And when you run it, it will look like: $ python main.py # Enter your name üòé:$ Morty Hello Morty Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Commands Intro - Typer Skip to content Typer Commands Intro Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Commands Intro Table of contents Command or subcommand Explicit application CLI application completion A CLI application with multiple commands Click Group Decorator Technical Details Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Command or subcommand Explicit application CLI application completion A CLI application with multiple commands Click Group Decorator Technical Details Commands Intro We have seen how to create a CLI program with possibly several CLI options and CLI arguments . But Typer allows you to create CLI programs with several commands (also known as subcommands). For example, the program git has several commands. One command of git is git push . And git push in turn takes its own CLI arguments and CLI options . For example: // The push command with no parameters $ git push ---> 100% // The push command with one CLI option --set-upstream and 2 CLI arguments $ git push --set-upstream origin master ---> 100% Another command of git is git pull , it also has some CLI parameters . It's like if the same big program git had several small programs inside. Tip A command looks the same as a CLI argument , it's just some name without a preceding -- . But commands have a predefined name, and are used to group different sets of functionalities into the same CLI application. Command or subcommand ¬∂ It's common to call a CLI program a "command". But when one of these programs have subcommands, those subcommands are also frequently called just "commands". Have that in mind so you don't get confused. Here I'll use CLI application or program to refer to the program you are building in Python with Typer, and command to refer to one of these "subcommands" of your program. Explicit application ¬∂ Before creating CLI applications with multiple commands/subcommands we need to understand how to create an explicit typer.Typer() application. In the CLI options and CLI argument tutorials you have seen how to create a single function and then pass that function to typer.run() . For example: import typer def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) But that is actually a shortcut. Under the hood, Typer converts that to a CLI application with typer.Typer() and executes it. All that inside of typer.run() . There's also a more explicit way to achieve the same: import typer app = typer . Typer () @app . command () def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () When you use typer.run() , Typer is doing more or less the same as above, it will: Create a new typer.Typer() "application". Create a new " command " with your function. Call the same "application" as if it was a function with " app() ". @decorator Info That @something syntax in Python is called a "decorator". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A "decorator" takes the function below and does something with it. In our case, this decorator tells Typer that the function below is a " command ". Both ways, with typer.run() and creating the explicit application, achieve almost the same. Tip If your use case is solved with just typer.run() , that's fine, you don't have to create the explicit app and use @app.command() , etc. You might want to do that later when your app needs the extra features, but if it doesn't need them yet, that's fine. If you run the second example, with the explicit app , it works exactly the same: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try "main.py --help" for help. Error: Missing argument 'NAME'. // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. CLI application completion ¬∂ There's a little detail that is worth noting here. Now the help shows two new CLI options : --install-completion --show-completion To get shell/tab completion, it's necessary to build a package that you and your users can install and call directly . So instead of running a Python script like: $ python main.py ‚ú® Some magic here ‚ú® ...It would be called like: $ magic-app ‚ú® Some magic here ‚ú® Having a standalone program like that allows setting up shell/tab completion. The first step to be able to create an installable package like that is to use an explicit typer.Typer() app. Later you can learn all the process to create a standalone CLI application and Build a Package . But for now, it's just good to know that you are on that path. üòé A CLI application with multiple commands ¬∂ Coming back to the CLI applications with multiple commands/subcommands, Typer allows creating CLI applications with multiple of them. Now that you know how to create an explicit typer.Typer() application and add one command, let's see how to add multiple commands. Let's say that we have a CLI application to manage users. We'll have a command to create users and another command to delete them. To begin, let's say it can only create and delete one single predefined user: import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . command () def delete (): print ( "Deleting user: Hiro Hamada" ) if __name__ == "__main__" : app () Now we have a CLI application with 2 commands, create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create delete // Test them $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada // Now we have 2 commands! üéâ Notice that the help text now shows the 2 commands: create and delete . Tip By default, the names of the commands are generated from the function name. Click Group ¬∂ If you come from Click, a typer.Typer app with subcommands is more or less the equivalent of a Click Group . Technical Details A typer.Typer app is not a Click Group, but it provides the equivalent functionality. And it creates a Click Group when calling it. It is not directly a Group because Typer doesn't modify the functions in your code to convert them to another type of object, it only registers them. Decorator Technical Details ¬∂ When you use @app.command() the function under the decorator is registered in the Typer application and is then used later by the application. But Typer doesn't modify that function itself, the function is left as is. That means that if your function is simple enough that you could create it without using typer.Option() or typer.Argument() , you could use the same function for a Typer application and a FastAPI application putting both decorators on top, or similar tricks. Click Technical Details This behavior is a design difference with Click. In Click, when you add a @click.command() decorator it actually modifies the function underneath and replaces it with an object. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Command CLI Options - Typer Typer Command CLI Options Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Command CLI Options Commands can also have their own CLI options . In fact, each command can have different CLI arguments and CLI options : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete the user?" ) ], ): if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete ALL users?" ) ] ): if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): print ( "Initializing user database" ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete the user?" ), ): if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete ALL users?" ) ): if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): print ( "Initializing user database" ) if __name__ == "__main__" : app () Here we have multiple commands, with different CLI parameters : create : username : a CLI argument . delete : username : a CLI argument . --force : a CLI option , if not provided, it's prompted. delete-all : --force : a CLI option , if not provided, it's prompted. init : Doesn't take any CLI parameters . // Check the help python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create delete delete-all info Tip Check the command delete-all , by default command names are generated from the function name, replacing _ with - . Test it: // Check the command create $ python main.py create Camila Creating user: Camila // Now test the command delete $ python main.py delete Camila # Are you sure you want to delete the user? [ y/N ] : $ y Deleting user: Camila $ python main.py delete Wade # Are you sure you want to delete the user? [ y/N ] : $ n Operation cancelled // And finally, the command delete-all // Notice it doesn't have CLI arguments, only a CLI option $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/N ] : $ y Deleting all users $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/N ] : $ n Operation cancelled // And if you pass the --force CLI option, it doesn't need to confirm $ python main.py delete-all --force Deleting all users // And init that doesn't take any CLI parameter $ python main.py init Initializing user database Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Using the Context - Typer Skip to content Typer Using the Context Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context Using the Context Table of contents Getting the context Executable callback Exclusive executable callback Configuring the context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Getting the context Executable callback Exclusive executable callback Configuring the context Using the Context When you create a Typer application it uses Click underneath. And every Click application has a special object called a "Context" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . You might have read it in CLI Option Callback and Context . The same way, in commands or in the main Typer callback you can access the context by declaring a function parameter of type typer.Context . Getting the context ¬∂ For example, let's say that you want to execute some logic in a Typer callback depending on the subcommand that is being called. You can get the name of the subcommand from the context: import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) @app . callback () def main ( ctx : typer . Context ): """ Manage users in the awesome CLI app. """ print ( f "About to execute command: { ctx . invoked_subcommand } " ) if __name__ == "__main__" : app () Check it: $ python main.py create Camila // We get the message from the callback About to execute command: create Creating user: Camila $ python main.py delete Camila // We get the message from the callback, this time with delete About to execute command: delete Deleting user: Camila Executable callback ¬∂ By default, the callback is only executed right before executing a command. And if no command is provided, the help message is shown. But we could make it run even without a subcommand with invoke_without_command=True : import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) @app . callback ( invoke_without_command = True ) def main (): """ Manage users in the awesome CLI app. """ print ( "Initializing database" ) if __name__ == "__main__" : app () Check it: $ python main.py // The callback is executed, we don't get the default help message Initializing database // Try with a command $ python main.py create Camila // The callback is still executed Initializing database Creating user: Camila Exclusive executable callback ¬∂ We might not want the callback to be executed if there's already other command that will be executed. For that, we can get the typer.Context and check if there's an invoked command in ctx.invoked_subcommand . If it's None , it means that we are not calling a subcommand but the main program (the callback) directly: import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) @app . callback ( invoke_without_command = True ) def main ( ctx : typer . Context ): """ Manage users in the awesome CLI app. """ if ctx . invoked_subcommand is None : print ( "Initializing database" ) if __name__ == "__main__" : app () Check it: $ python main.py // The callback is executed Initializing database // Check it with a subcommand $ python main.py create Camila // This time the callback is not executed Creating user: Camila Configuring the context ¬∂ You can pass configurations for the context when creating a command or callback. To read more about the available configurations check the docs for Click's Context . For example, you could keep additional CLI parameters not declared in your CLI program with ignore_unknown_options and allow_extra_args . Then you can access those extra raw CLI parameters as a list of str in ctx.args : import typer app = typer . Typer () @app . command ( context_settings = { "allow_extra_args" : True , "ignore_unknown_options" : True } ) def main ( ctx : typer . Context ): for extra_arg in ctx . args : print ( f "Got extra arg: { extra_arg } " ) if __name__ == "__main__" : app () $ python main.py --name Camila --city Berlin Got extra arg: --name Got extra arg: Camila Got extra arg: --city Got extra arg: Berlin Tip Notice that it saves all the extra CLI parameters as a raw list of str , including the CLI option names and values, everything together. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

One or Multiple Commands - Typer Skip to content Typer One or Multiple Commands Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands One or Multiple Commands Table of contents One command and one callback Using the callback to document Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents One command and one callback Using the callback to document One or Multiple Commands You might have noticed that if you create a single command, as in the first example: import typer app = typer . Typer () @app . command () def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : app () Typer is smart enough to create a CLI application with that single function as the main CLI application, not as a command/subcommand: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try "main.py --help" for help. Error: Missing argument 'NAME'. // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py Usage: main.py [OPTIONS] NAME Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Tip Notice that it doesn't show a command main , even though the function name is main . But if you add multiple commands, Typer will create one CLI command for each one of them: import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . command () def delete (): print ( "Deleting user: Hiro Hamada" ) if __name__ == "__main__" : app () Here we have 2 commands create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create delete // Test the commands $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada One command and one callback ¬∂ If you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback: import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . callback () def callback (): pass if __name__ == "__main__" : app () And now your CLI program will have a single command. Check it: // Check the help $ python main.py --help // Notice the single command create Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create // Try it $ python main.py create Creating user: Hiro Hamada Using the callback to document ¬∂ Now that you are using a callback just to have a single command, you might as well use it to add documentation for your app: import typer app = typer . Typer () @app . command () def create (): print ( "Creating user: Hiro Hamada" ) @app . callback () def callback (): """ Creates a single user Hiro Hamada. In the next version it will create 5 users more. """ if __name__ == "__main__" : app () And now the docstring from the callback will be used as the help text: $ python main.py --help // Notice the help text from the docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Creates a single user Hiro Hamada. In the next version it will create 5 users more. Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create // And it still works the same, the callback does nothing $ python main.py create Creating user: Hiro Hamada Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Typer Callback - Typer Skip to content Typer Typer Callback Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback Typer Callback Table of contents Adding a callback on creation Overriding a callback Adding a callback only for documentation Click Group One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Adding a callback on creation Overriding a callback Adding a callback only for documentation Click Group Typer Callback When you create an app = typer.Typer() it works as a group of commands. And you can create multiple commands with it. Each of those commands can have their own CLI parameters . But as those CLI parameters are handled by each of those commands, they don't allow us to create CLI parameters for the main CLI application itself. But we can use @app.callback() for that. It's very similar to @app.command() , but it declares the CLI parameters for the main CLI application (before the commands): import typer app = typer . Typer () state = { "verbose" : False } @app . command () def create ( username : str ): if state [ "verbose" ]: print ( "About to create a user" ) print ( f "Creating user: { username } " ) if state [ "verbose" ]: print ( "Just created a user" ) @app . command () def delete ( username : str ): if state [ "verbose" ]: print ( "About to delete a user" ) print ( f "Deleting user: { username } " ) if state [ "verbose" ]: print ( "Just deleted a user" ) @app . callback () def main ( verbose : bool = False ): """ Manage users in the awesome CLI app. """ if verbose : print ( "Will write verbose output" ) state [ "verbose" ] = True if __name__ == "__main__" : app () Here we create a callback with a --verbose CLI option . Tip After getting the --verbose flag, we modify a global state , and we use it in the other commands. There are other ways to achieve the same, but this will suffice for this example. And as we added a docstring to the callback function, by default it will be extracted and used as the help text. Check it: // Check the help $ python main.py --help // Notice the main help text, extracted from the callback function: "Manage users in the awesome CLI app." Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users in the awesome CLI app. Options: --verbose / --no-verbose  [default: False] --install-completion      Install completion for the current shell. --show-completion         Show completion for the current shell, to copy it or customize the installation. --help                    Show this message and exit. Commands: create delete // Check the new top level CLI option --verbose // Try it normally $ python main.py create Camila Creating user: Camila // And now with --verbose $ python main.py --verbose create Camila Will write verbose output About to create a user Creating user: Camila Just created a user // Notice that --verbose belongs to the callback, it has to go before create or delete ‚õîÔ∏è $ python main.py create --verbose Camila Usage: main.py create [OPTIONS] USERNAME Try "main.py create --help" for help. Error: no such option: --verbose Adding a callback on creation ¬∂ It's also possible to add a callback when creating the typer.Typer() app: import typer def callback (): print ( "Running a command" ) app = typer . Typer ( callback = callback ) @app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () That achieves the same as with @app.callback() . Check it: $ python main.py create Camila Running a command Creating user: Camila Overriding a callback ¬∂ If you added a callback when creating the typer.Typer() app, it's possible to override it with @app.callback() : import typer def callback (): print ( "Running a command" ) app = typer . Typer ( callback = callback ) @app . callback () def new_callback (): print ( "Override callback, running a command" ) @app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Now new_callback() will be the one used. Check it: $ python main.py create Camila // Notice that the message is the one from new_callback() Override callback, running a command Creating user: Camila Adding a callback only for documentation ¬∂ You can also add a callback just to add the documentation in the docstring. It can be convenient especially if you have several lines of text, as the indentation will be automatically handled for you: import typer app = typer . Typer () @app . callback () def callback (): """ Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. """ @app . command () def create ( name : str ): print ( f "Creating user: { name } " ) if __name__ == "__main__" : app () Now the callback will be used mainly to extract the docstring for the help text. Check it: $ python main.py --help // Notice all the help text extracted from the callback docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create // And it just works as normally $ python main.py create Camila Creating user: Camila Click Group ¬∂ If you come from Click, this Typer callback is the equivalent of the function in a Click Group . For example: import click @click . group () def cli (): pass The original function cli would be the equivalent of a Typer callback. Technical Details When using Click, it converts that cli variable to a Click Group object. And then the original function no longer exists in that variable. Typer doesn't do that, the callback function is not modified, only registered in the typer.Typer app. This is intentional, it's part of Typer 's design, to allow having editor auto completion and type checks. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Custom Command Name - Typer Typer Custom Command Name Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Custom Command Name By default, the command names are generated from the function name. So, if your function is something like: def create ( username : str ): ... Then the command name will be create . But if you already had a function called create() somewhere in your code, you would have to name your CLI function differently. And what if you wanted the command to still be named create ? For this, you can set the name of the command in the first parameter for the @app.command() decorator: import typer app = typer . Typer () @app . command ( "create" ) def cli_create_user ( username : str ): print ( f "Creating user: { username } " ) @app . command ( "delete" ) def cli_delete_user ( username : str ): print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () Now, even though the functions are named cli_create_user() and cli_delete_user() , the commands will still be named create and delete : $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create delete // Test it $ python main.py create Camila Creating user: Camila Note that any underscores in the function name will be replaced with dashes. So if your function is something like: def create_user ( username : str ): ... Then the command name will be create-user . Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Command CLI Arguments - Typer Typer Command CLI Arguments Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Command CLI Arguments The same way as with a CLI application with a single command, subcommands (or just "commands") can also have their own CLI arguments : import typer app = typer . Typer () @app . command () def create ( username : str ): print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Options: --help  Show this message and exit. // Call it with a CLI argument $ python main.py create Camila Creating user: Camila // The same for delete $ python main.py delete Camila Deleting user: Camila Tip Everything to the right of the command are CLI parameters ( CLI arguments and CLI options ) for that command. Technical Details Actually, it's everything to the right of that command, before any subcommand . It's possible to have groups of subcommands , it's like if one command also had subcommands . And then those subcommands could have their own CLI parameters , taking their own CLI parameters . You will see about them later in another section. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Command Help - Typer Skip to content Typer Command Help Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Command Help Table of contents Overwrite command help Deprecate a Command Rich Markdown and Markup Rich Markup Rich Markdown Help Panels Help Panels for Commands Help Panels for CLI Parameters Epilog Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Overwrite command help Deprecate a Command Rich Markdown and Markup Rich Markup Rich Markdown Help Panels Help Panels for Commands Help Panels for CLI Parameters Epilog Command Help The same as before, you can add help for the commands in the docstrings and the CLI options . And the typer.Typer() application receives a parameter help that you can pass with the main help text for your CLI program: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated app = typer . Typer ( help = "Awesome CLI user manager." ) @app . command () def create ( username : str ): """ Create a new user with USERNAME. """ print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete the user?" , help = "Force deletion without confirmation." , ), ], ): """ Delete a user with USERNAME. If --force is not used, will ask for confirmation. """ if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : Annotated [ bool , typer . Option ( prompt = "Are you sure you want to delete ALL users?" , help = "Force deletion without confirmation." , ), ] ): """ Delete ALL users in the database. If --force is not used, will ask for confirmation. """ if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): """ Initialize the users database. """ print ( "Initializing user database" ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer ( help = "Awesome CLI user manager." ) @app . command () def create ( username : str ): """ Create a new user with USERNAME. """ print ( f "Creating user: { username } " ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete the user?" , help = "Force deletion without confirmation." , ), ): """ Delete a user with USERNAME. If --force is not used, will ask for confirmation. """ if force : print ( f "Deleting user: { username } " ) else : print ( "Operation cancelled" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = "Are you sure you want to delete ALL users?" , help = "Force deletion without confirmation." , ) ): """ Delete ALL users in the database. If --force is not used, will ask for confirmation. """ if force : print ( "Deleting all users" ) else : print ( "Operation cancelled" ) @app . command () def init (): """ Initialize the users database. """ print ( "Initializing user database" ) if __name__ == "__main__" : app () Check it: // Check the new help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Awesome CLI user manager. Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create      Create a new user with USERNAME. delete      Delete a user with USERNAME. delete-all  Delete ALL users in the database. init        Initialize the users database. // Now the commands have inline help üéâ // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Create a new user with USERNAME. Options: --help  Show this message and exit. // Check the help for delete $ python main.py delete --help Usage: main.py delete [OPTIONS] USERNAME Delete a user with USERNAME. If --force is not used, will ask for confirmation. Options: --force / --no-force  Force deletion without confirmation.  [required] --help                Show this message and exit. // Check the help for delete-all $ python main.py delete-all --help Usage: main.py delete-all [OPTIONS] Delete ALL users in the database. If --force is not used, will ask for confirmation. Options: --force / --no-force  Force deletion without confirmation.  [required] --help                Show this message and exit. // Check the help for init $ python main.py init --help Usage: main.py init [OPTIONS] Initialize the users database. Options: --help  Show this message and exit. Tip typer.Typer() receives several other parameters for other things, we'll see that later. You will also see how to use "Callbacks" later, and those include a way to add this same help message in a function docstring. Overwrite command help ¬∂ You will probably be better adding the help text as a docstring to your functions, but if for some reason you wanted to overwrite it, you can use the help function argument passed to @app.command() : import typer app = typer . Typer () @app . command ( help = "Create a new user with USERNAME." ) def create ( username : str ): """ Some internal utility function to create. """ print ( f "Creating user: { username } " ) @app . command ( help = "Delete a user with USERNAME." ) def delete ( username : str ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () Check it: // Check the help $ python main.py --help // Notice it uses the help passed to @app.command() Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: create  Create a new user with USERNAME. delete  Delete a user with USERNAME. // It uses "Create a new user with USERNAME." instead of "Some internal utility function to create." Deprecate a Command ¬∂ There could be cases where you have a command in your app that you need to deprecate, so that your users stop using it, even while it's still supported for a while. You can mark it with the parameter deprecated=True : import typer app = typer . Typer () @app . command () def create ( username : str ): """ Create a user. """ print ( f "Creating user: { username } " ) @app . command ( deprecated = True ) def delete ( username : str ): """ Delete a user. This is deprecated and will stop being supported soon. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () And when you show the --help option you will see it's marked as " deprecated ": $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] COMMAND [ARGS]...                  </b> <b>                                                                     </b> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--install-completion</b></font>          Install completion for the current  ‚îÇ <font color="#A5A5A1">‚îÇ                               shell.                              ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--show-completion</b></font>             Show completion for the current     ‚îÇ <font color="#A5A5A1">‚îÇ                               shell, to copy it or customize the  ‚îÇ</font> <font color="#A5A5A1">‚îÇ                               installation.                       ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                        Show this message and exit.         ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>create       </b></font> Create a user.                                      ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#6B9F98"><b>delete       </b></font> Delete a user.              <font color="#F92672">(deprecated)           </font> ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> And if you check the --help for the deprecated command (in this example, the command delete ), it also shows it as deprecated: $ python main.py delete --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py delete [OPTIONS] USERNAME                    </b> <b>                                                                     </b> <font color="#F92672">(deprecated) </font> Delete a user. This is deprecated and will stop being supported soon. <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    username      <font color="#F4BF75"><b>TEXT</b></font>  [default: None] <font color="#A6194C">[required]</font>               ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>          Show this message and exit.                       ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Rich Markdown and Markup ¬∂ If you have Rich installed as described in Printing and Colors , you can configure your app to enable markup text with the parameter rich_markup_mode . Then you can use more formatting in the docstrings and the help parameter for CLI arguments and CLI options . You will see more about it below. üëá Info By default, rich_markup_mode is None , which disables any rich text formatting. Rich Markup ¬∂ If you set rich_markup_mode="rich" when creating the typer.Typer() app, you will be able to use Rich Console Markup in the docstring, and even in the help for the CLI arguments and options: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : Annotated [ str , typer . Argument ( help = "The username to be [green]created[/green]" ) ] ): """ [bold green]Create[/bold green] a new [italic]shinny[/italic] user. :sparkles: This requires a [underline]username[/underline]. """ print ( f "Creating user: { username } " ) @app . command ( help = "[bold red]Delete[/bold red] a user with [italic]USERNAME[/italic]." ) def delete ( username : Annotated [ str , typer . Argument ( help = "The username to be [red]deleted[/red]" ) ], force : Annotated [ bool , typer . Option ( help = "Force the [bold red]deletion[/bold red] :boom:" ) ] = False , ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : str = typer . Argument ( ... , help = "The username to be [green]created[/green]" ) ): """ [bold green]Create[/bold green] a new [italic]shiny[/italic] user. :sparkles: This requires a [underline]username[/underline]. """ print ( f "Creating user: { username } " ) @app . command ( help = "[bold red]Delete[/bold red] a user with [italic]USERNAME[/italic]." ) def delete ( username : str = typer . Argument ( ... , help = "The username to be [red]deleted[/red]" ), force : bool = typer . Option ( False , help = "Force the [bold red]deletion[/bold red] :boom:" ), ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () With that, you can use Rich Console Markup to format the text in the docstring for the command create , make the word " create " bold and green, and even use an emoji . You can also use markup in the help for the username CLI Argument. And the same as before, the help text overwritten for the command delete can also use Rich Markup, the same in the CLI Argument and CLI Option. If you run the program and check the help, you will see that Typer uses Rich internally to format the help. Check the help for the create command: $ python main.py create --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py create [OPTIONS] USERNAME                     </b> <b>                                                                     </b> <font color="#A6E22E"><b>Create</b></font> a new <i>shiny</i> user. ‚ú® This requires a <font color="#A5A5A1"><u style="text-decoration-style:single">username</u></font><font color="#A5A5A1">.                                           </font> <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    username      <font color="#F4BF75"><b>TEXT</b></font>  The username to be <font color="#A6E22E">created</font>               ‚îÇ <font color="#A5A5A1">‚îÇ                          [default: None]                          ‚îÇ</font> <font color="#A5A5A1">‚îÇ                          </font><font color="#A6194C">[required]                </font>               ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>          Show this message and exit.                       ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> And check the help for the delete command: $ python main.py delete --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py delete [OPTIONS] USERNAME                     </b> <b>                                                                     </b> <font color="#F92672"><b>Delete</b></font> a user with <i>USERNAME</i>. <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    username      <font color="#F4BF75"><b>TEXT</b></font>  The username to be <font color="#F92672">deleted</font>               ‚îÇ <font color="#A5A5A1">‚îÇ                          [default: None]                          ‚îÇ</font> <font color="#A5A5A1">‚îÇ                          </font><font color="#A6194C">[required]                </font>               ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--force</b></font>    <font color="#AE81FF"><b>--no-force</b></font>      Force the <font color="#F92672"><b>deletion</b></font> üí•                  ‚îÇ <font color="#A5A5A1">‚îÇ                            [default: no-force]                    ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                     Show this message and exit.            ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Rich Markdown ¬∂ If you set rich_markup_mode="markdown" when creating the typer.Typer() app, you will be able to use Markdown in the docstring: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated app = typer . Typer ( rich_markup_mode = "markdown" ) @app . command () def create ( username : Annotated [ str , typer . Argument ( help = "The username to be **created**" )] ): """ **Create** a new *shinny* user. :sparkles: * Create a username * Show that the username is created --- Learn more at the [Typer docs website](https://typer.tiangolo.com) """ print ( f "Creating user: { username } " ) @app . command ( help = "**Delete** a user with *USERNAME*." ) def delete ( username : Annotated [ str , typer . Argument ( help = "The username to be **deleted**" )], force : Annotated [ bool , typer . Option ( help = "Force the **deletion** :boom:" )] = False , ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. import typer app = typer . Typer ( rich_markup_mode = "markdown" ) @app . command () def create ( username : str = typer . Argument ( ... , help = "The username to be **created**" )): """ **Create** a new *shiny* user. :sparkles: * Create a username * Show that the username is created --- Learn more at the [Typer docs website](https://typer.tiangolo.com) """ print ( f "Creating user: { username } " ) @app . command ( help = "**Delete** a user with *USERNAME*." ) def delete ( username : str = typer . Argument ( ... , help = "The username to be **deleted**" ), force : bool = typer . Option ( False , help = "Force the **deletion** :boom:" ), ): """ Some internal utility function to delete. """ print ( f "Deleting user: { username } " ) if __name__ == "__main__" : app () With that, you can use Markdown to format the text in the docstring for the command create , make the word " create " bold, show a list of items, and even use an emoji . And the same as before, the help text overwritten for the command delete can also use Markdown. Check the help for the create command: $ python main.py create --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py create [OPTIONS] USERNAME                     </b> <b>                                                                     </b> <b>Create</b> a new <i>shiny</i> user. ‚ú® <font color="#F4BF75"><b> ‚Ä¢ </b></font><font color="#A5A5A1">Create a username                                                </font> <font color="#F4BF75"><b> ‚Ä¢ </b></font><font color="#A5A5A1">Show that the username is created                                </font> <font color="#F4BF75">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</font> Learn more at the <font color="#44919F">Typer docs website</font> <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    username      <font color="#F4BF75"><b>TEXT</b></font>  The username to be <b>created</b>               ‚îÇ <font color="#A5A5A1">‚îÇ                          [default: None]                          ‚îÇ</font> <font color="#A5A5A1">‚îÇ                          </font><font color="#A6194C">[required]                              </font> ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>          Show this message and exit.                       ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> And the same for the delete command: $ python main.py delete --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py delete [OPTIONS] USERNAME                     </b> <b>                                                                     </b> <b>Delete</b> a user with <i>USERNAME</i>. <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    username      <font color="#F4BF75"><b>TEXT</b></font>  The username to be <b>deleted</b>               ‚îÇ <font color="#A5A5A1">‚îÇ                          [default: None]                          ‚îÇ</font> <font color="#A5A5A1">‚îÇ                          </font><font color="#A6194C">[required]                              </font> ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--force</b></font>    <font color="#AE81FF"><b>--no-force</b></font>      Force the <b>deletion</b> üí•                  ‚îÇ <font color="#A5A5A1">‚îÇ                            [default: no-force]                    ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                     Show this message and exit.            ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Info Notice that in Markdown you cannot define colors. For colors you might prefer to use Rich markup. Help Panels ¬∂ If you have many commands or CLI parameters, you might want to show their documentation in different panels when using the --help option. If you installed Rich as described in Printing and Colors , you can configure the panel to use for each command or CLI parameter. Help Panels for Commands ¬∂ To set the panel for a command you can pass the argument rich_help_panel with the name of the panel you want to use: Python 3.6+ import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : str ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) @app . command () def delete ( username : str ): """ [red]Delete[/red] a user. :fire: """ print ( f "Deleting user: { username } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def config ( configuration : str ): """ [blue]Configure[/blue] the system. :wrench: """ print ( f "Configuring the system with: { configuration } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def sync (): """ [blue]Synchronize[/blue] the system or something fancy like that. :recycle: """ print ( "Syncing the system" ) @app . command ( rich_help_panel = "Help and Others" ) def help (): """ Get [yellow]help[/yellow] with the system. :question: """ print ( "Opening help portal..." ) @app . command ( rich_help_panel = "Help and Others" ) def report (): """ [yellow]Report[/yellow] an issue. :bug: """ print ( "Please open a new issue online, not a direct message" ) if __name__ == "__main__" : app () Commands without a panel will be shown in the default panel Commands , and the rest will be shown in the next panels: $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] COMMAND [ARGS]...                   </b> <b>                                                                     </b> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--install-completion</b></font>          Install completion for the current  ‚îÇ <font color="#A5A5A1">‚îÇ                               shell.                              ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--show-completion</b></font>             Show completion for the current     ‚îÇ <font color="#A5A5A1">‚îÇ                               shell, to copy it or customize the  ‚îÇ</font> <font color="#A5A5A1">‚îÇ                               installation.                       ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                        Show this message and exit.         ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>create          </b></font> <font color="#A6E22E">Create</font> a new user. ‚ú®                            ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>delete          </b></font> <font color="#F92672">Delete</font> a user. üî•                                ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Utils and Configs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>config  </b></font> <font color="#66D9EF">Configure</font> the system. üîß                                 ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>sync    </b></font> <font color="#66D9EF">Synchronize</font> the system or something fancy like that. ‚ôª   ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Help and Others ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>help         </b></font> Get <font color="#F4BF75">help</font> with the system. ‚ùì                        ‚îÇ <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>report       </b></font> <font color="#F4BF75">Report</font> an issue. üêõ                                 ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Help Panels for CLI Parameters ¬∂ The same way, you can configure the panels for CLI arguments and CLI options with rich_help_panel . And of course, in the same application you can also set the rich_help_panel for commands. Python 3.6+ Python 3.6+ non-Annotated from typing import Union import typer from typing_extensions import Annotated app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : Annotated [ str , typer . Argument ( help = "The username to create" )], lastname : Annotated [ str , typer . Argument ( help = "The last name of the new user" , rich_help_panel = "Secondary Arguments" ), ] = "" , force : Annotated [ bool , typer . Option ( help = "Force the creation of the user" )] = False , age : Annotated [ Union [ int , None ], typer . Option ( help = "The age of the new user" , rich_help_panel = "Additional Data" ), ] = None , favorite_color : Annotated [ Union [ str , None ], typer . Option ( help = "The favorite color of the new user" , rich_help_panel = "Additional Data" , ), ] = None , ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def config ( configuration : str ): """ [blue]Configure[/blue] the system. :wrench: """ print ( f "Configuring the system with: { configuration } " ) if __name__ == "__main__" : app () Tip Prefer to use the Annotated version if possible. from typing import Union import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command () def create ( username : str = typer . Argument ( ... , help = "The username to create" ), lastname : str = typer . Argument ( "" , help = "The last name of the new user" , rich_help_panel = "Secondary Arguments" ), force : bool = typer . Option ( False , help = "Force the creation of the user" ), age : Union [ int , None ] = typer . Option ( None , help = "The age of the new user" , rich_help_panel = "Additional Data" ), favorite_color : Union [ str , None ] = typer . Option ( None , help = "The favorite color of the new user" , rich_help_panel = "Additional Data" , ), ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) @app . command ( rich_help_panel = "Utils and Configs" ) def config ( configuration : str ): """ [blue]Configure[/blue] the system. :wrench: """ print ( f "Configuring the system with: { configuration } " ) if __name__ == "__main__" : app () Then if you run the application you will see all the CLI parameters in their respective panels. First the CLI arguments that don't have a panel name set in a default one named " Arguments ". Next the CLI arguments with a custom panel . In this example named " Secondary Arguments ". After that, the CLI options that don't have a panel in a default one named " Options ". And finally, the CLI options with a custom panel set. In this example named " Additional Data ". You can check the --help option for the command create : $ python main.py create --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py create [OPTIONS] USERNAME [LASTNAME]          </b> <b>                                                                     </b> <font color="#A6E22E">Create</font> a new user. ‚ú® <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    username      <font color="#F4BF75"><b>TEXT</b></font>  The username to create [default: None]   ‚îÇ <font color="#A5A5A1">‚îÇ                          </font><font color="#A6194C">[required]            </font>                   ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Secondary Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ   lastname      </font><font color="#A37F4E"><b>[LASTNAME]</b></font>  The last name of the new user         ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--force</b></font>    <font color="#AE81FF"><b>--no-force</b></font>      Force the creation of the user         ‚îÇ <font color="#A5A5A1">‚îÇ                            [default: no-force]                    ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                     Show this message and exit.            ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Additional Data ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--age</b></font>                   <font color="#F4BF75"><b>INTEGER</b></font>  The age of the new user          ‚îÇ <font color="#A5A5A1">‚îÇ                                  [default: None]                  ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--favorite-color</b></font>        <font color="#F4BF75"><b>TEXT   </b></font>  The favorite color of the new    ‚îÇ <font color="#A5A5A1">‚îÇ                                  user                             ‚îÇ</font> <font color="#A5A5A1">‚îÇ                                  [default: None]                  ‚îÇ</font> <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> And of course, the rich_help_panel can be used in the same way for commands in the same application. And those panels will be shown when you use the main --help option. $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] COMMAND [ARGS]...                   </b> <b>                                                                     </b> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--install-completion</b></font>          Install completion for the current  ‚îÇ <font color="#A5A5A1">‚îÇ                               shell.                              ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--show-completion</b></font>             Show completion for the current     ‚îÇ <font color="#A5A5A1">‚îÇ                               shell, to copy it or customize the  ‚îÇ</font> <font color="#A5A5A1">‚îÇ                               installation.                       ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                        Show this message and exit.         ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>create          </b></font> <font color="#A6E22E">Create</font> a new user. ‚ú®                            ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Utils and Configs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>config         </b></font> <font color="#66D9EF">Configure</font> the system. üîß                          ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> You can see the custom panel for the commands for " Utils and Configs ". Epilog ¬∂ If you need, you can also add an epilog section to the help of your commands: import typer app = typer . Typer ( rich_markup_mode = "rich" ) @app . command ( epilog = "Made with :heart: in [blue]Venus[/blue]" ) def create ( username : str ): """ [green]Create[/green] a new user. :sparkles: """ print ( f "Creating user: { username } " ) if __name__ == "__main__" : app () And when you check the --help option it will look like: $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] USERNAME                            </b> <b>                                                                     </b> <font color="#A6E22E">Create</font> a new user. ‚ú® <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    username      <font color="#F4BF75"><b>TEXT</b></font>  [default: None] <font color="#A6194C">[required]</font>               ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--install-completion</b></font>          Install completion for the current  ‚îÇ <font color="#A5A5A1">‚îÇ                               shell.                              ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--show-completion</b></font>             Show completion for the current     ‚îÇ <font color="#A5A5A1">‚îÇ                               shell, to copy it or customize the  ‚îÇ</font> <font color="#A5A5A1">‚îÇ                               installation.                       ‚îÇ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                        Show this message and exit.         ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> Made with ‚ù§ in <font color="#66D9EF">Venus</font> Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Terminating - Typer Skip to content Typer Terminating Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating Terminating Table of contents Exit a CLI program Exit with an error Abort CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Exit a CLI program Exit with an error Abort Terminating There are some cases where you might want to terminate a command at some point, and stop all subsequent execution. It could be that your code determined that the program completed successfully, or it could be an operation aborted. Exit a CLI program ¬∂ You can normally just let the code of your CLI program finish its execution, but in some scenarios, you might want to terminate at some point in the middle of it. And prevent any subsequent code to run. This doesn't have to mean that there's an error, just that nothing else needs to be executed. In that case, you can raise a typer.Exit() exception: import typer existing_usernames = [ "rick" , "morty" ] def maybe_create_user ( username : str ): if username in existing_usernames : print ( "The user already exists" ) raise typer . Exit () else : print ( f "User created: { username } " ) def send_new_user_notification ( username : str ): # Somehow send a notification here for the new user, maybe an email print ( f "Notification sent for new user: { username } " ) def main ( username : str ): maybe_create_user ( username = username ) send_new_user_notification ( username = username ) if __name__ == "__main__" : typer . run ( main ) There are several things to see in this example. The CLI program is the function main() , not the others. This is the one that takes a CLI argument . The function maybe_create_user() can terminate the program by raising typer.Exit() . If the program is terminated by maybe_create_user() then send_new_user_notification() will never execute inside of main() . Check it: $ python main.py Camila User created: Camila Notification sent for new user: Camila // Try with an existing user $ python main.py rick The user already exists // Notice that the notification code was never run, the second message is not printed Tip Even though you are raising an exception, it doesn't necessarily mean there's an error. This is done with an exception because it works as an "error" and stops all execution. But then Typer (actually Click) catches it and just terminates the program normally. Exit with an error ¬∂ typer.Exit() takes an optional code parameter. By default, code is 0 , meaning there was no error. You can pass a code with a number other than 0 to tell the terminal that there was an error in the execution of the program: import typer def main ( username : str ): if username == "root" : print ( "The root user is reserved" ) raise typer . Exit ( code = 1 ) print ( f "New user created: { username } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Print the result code of the last program executed $ echo $? 0 // Now make it exit with an error $ python main.py root The root user is reserved // Print the result code of the last program executed $ echo $? 1 // 1 means there was an error, 0 means no errors. Tip The error code might be used by other programs (for example a Bash script) that execute your CLI program. Abort ¬∂ There's a special exception that you can use to "abort" a program. It works more or less the same as typer.Exit() but will print "Aborted!" to the screen and can be useful in certain cases later to make it explicit that the execution was aborted: import typer def main ( username : str ): if username == "root" : print ( "The root user is reserved" ) raise typer . Abort () print ( f "New user created: { username } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Now make it exit with an error $ python main.py root The root user is reserved Aborted! Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Arguments Intro - Typer Typer CLI Arguments Intro Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes CLI Arguments Intro In the next few sections we'll see some ways to modify how CLI arguments work. We'll create optional CLI arguments , we'll add integrated help for CLI arguments , etc. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Arguments with Environment Variables - Typer Skip to content Typer CLI Arguments with Environment Variables Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables CLI Arguments with Environment Variables Table of contents Multiple environment variables Hide an env var from the help text Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Multiple environment variables Hide an env var from the help text CLI Arguments with Environment Variables You can also configure a CLI argument to read a value from an environment variable if it is not provided in the command line as a CLI argument . To do that, use the envvar parameter for typer.Argument() : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( envvar = "AWESOME_NAME" )] = "World" ): print ( f "Hello Mr. { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "World" , envvar = "AWESOME_NAME" )): print ( f "Hello Mr. { name } " ) if __name__ == "__main__" : typer . run ( main ) In this case, the CLI argument name will have a default value of "World" , but will also read any value passed to the environment variable AWESOME_NAME if no value is provided in the command line: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME]  [env var: AWESOME_NAME;default: World] Options: --help                Show this message and exit. // Call it without a CLI argument $ python main.py Hello Mr. World // Now pass a value for the CLI argument $ python main.py Czernobog Hello Mr. Czernobog // And now use the environment variable $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday // CLI arguments take precedence over env vars $ AWESOME_NAME = Wednesday python main.py Czernobog Hello Mr. Czernobog Multiple environment variables ¬∂ You are not restricted to a single environment variable, you can declare a list of environment variables that could be used to get a value if it was not passed in the command line: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( envvar = [ "AWESOME_NAME" , "GOD_NAME" ])] = "World" ): print ( f "Hello Mr. { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "World" , envvar = [ "AWESOME_NAME" , "GOD_NAME" ])): print ( f "Hello Mr. { name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME]  [env var: AWESOME_NAME, GOD_NAME;default: World] Options: --help                Show this message and exit. // Try the first env var $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday // Try the second env var $ GOD_NAME = Anubis python main.py Hello Mr. Anubis Hide an env var from the help text ¬∂ By default, environment variables used will be shown in the help text, but you can disable them with show_envvar=False : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( envvar = "AWESOME_NAME" , show_envvar = False ) ] = "World" ): print ( f "Hello Mr. { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "World" , envvar = "AWESOME_NAME" , show_envvar = False )): print ( f "Hello Mr. { name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: //Check the help $ python main.py --help // It won't show the env var Usage: main.py [OPTIONS] [NAME] Arguments: [NAME]  [default: World] Options: --help                Show this message and exit. // But it will still be able to use it $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday Technical Details In Click applications the env vars are hidden by default. üôà In Typer these env vars are shown by default. üëÄ Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Arguments with Default - Typer Skip to content Typer CLI Arguments with Default Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Default Table of contents An optional CLI argument with a default Dynamic default value CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents An optional CLI argument with a default Dynamic default value CLI Arguments with Default We can also use the same typer.Argument() to set a default value. That way the CLI argument will be optional and also have a default value. An optional CLI argument with a default ¬∂ We can also use typer.Argument() to make a CLI argument have a default value other than None : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ()] = "Wade Wilson" ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "Wade Wilson" )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Because now the value will be a str passed by the user or the default value of "Wade Wilson" which is also a str , we know the value will never be None , so we don't have to (and shouldn't) use Optional[str] . Have in mind that the Optional[something] tells Python that a value "could be None ". But the use of Optional doesn't affect Typer in any way, e.g. it doesn't tell Typer if a value is required or not. Check it: // Check the help $ python main.py --help // Notice the [default: Wade Wilson] ‚ú® Usage: main.py [OPTIONS] [NAME] Arguments: [NAME]  [default: Wade Wilson] Options: --help                Show this message and exit. // With no optional CLI argument $ python main.py Hello Wade Wilson // With one CLI argument $ python main.py Camila Hello Camila Dynamic default value ¬∂ And we can even make the default value be dynamically generated by passing a function as the default_factory argument: Python 3.6+ Python 3.6+ non-Annotated import random import typer from typing_extensions import Annotated def get_name (): return random . choice ([ "Deadpool" , "Rick" , "Morty" , "Hiro" ]) def main ( name : Annotated [ str , typer . Argument ( default_factory = get_name )]): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import random import typer def get_name (): return random . choice ([ "Deadpool" , "Rick" , "Morty" , "Hiro" ]) def main ( name : str = typer . Argument ( default_factory = get_name )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) In this case, we created the function get_name that will just return a random str each time. And we pass it as the first function argument to typer.Argument() . Tip The word "factory" in default_factory is just a fancy way of saying "function that will create the default value". Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME]  [default: (dynamic)] Options: --help                Show this message and exit. // Try it several times, it will use a random default each time $ python main.py Hello Deadpool $ python main.py Hello Hiro $ python main.py Hello Rick // Now pass a value for the CLI argument $ python main.py Camila Hello Camila Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Optional CLI Arguments - Typer Skip to content Typer Optional CLI Arguments Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments Optional CLI Arguments Table of contents An alternative CLI argument declaration Make an optional CLI argument Alternative (old) typer.Argument() as the default value CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents An alternative CLI argument declaration Make an optional CLI argument Alternative (old) typer.Argument() as the default value Optional CLI Arguments We said before that by default : CLI options are optional CLI arguments are required Again, that's how they work by default , and that's the convention in many CLI programs and systems. But you can change that. In fact, it's very common to have optional CLI arguments , it's way more common than having required CLI options . As an example of how it could be useful, let's see how the ls CLI program works. // If you just type $ ls // ls will "list" the files and directories in the current directory typer  tests  README.md  LICENSE // But it also receives an optional CLI argument $ ls ./tests/ // And then ls will list the files and directories inside of that directory from the CLI argument __init__.py  test_tutorial An alternative CLI argument declaration ¬∂ In the First Steps you saw how to add a CLI argument : import typer def main ( name : str ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Now let's see an alternative way to create the same CLI argument : import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ()]): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Info Typer added support for Annotated (and started recommending it) in version 0.9.0. If you have an older version, you would get errors when trying to use Annotated . Make sure you Upgrade the Typer version to at least 0.9.0 before using Annotated . Before, you had this function parameter: name : str And now we wrap it with Annotated : name : Annotated [ str ] Both of these versions mean the same thing, Annotated is part of standard Python and is there for this. But the second version using Annotated allows us to pass additional metadata that can be used by Typer : name : Annotated [ str , typer . Argument ()] Now we are being explicit that name is a CLI argument . It's still a str and it's still required (it doesn't have a default value). All we did there achieves the same thing as before, a required CLI argument : $ python main.py Usage: main.py [OPTIONS] NAME Try "main.py --help" for help. Error: Missing argument 'NAME'. It's still not very useful, but it works correctly. And being able to declare a required CLI argument using name : Annoated [ str , typer . Argument ()] ...that works exactly the same as name : str ...will come handy later. Make an optional CLI argument ¬∂ Now, finally what we came for, an optional CLI argument . To make a CLI argument optional, use typer.Argument() and pass a different "default" as the first parameter to typer.Argument() , for example None : from typing import Optional import typer from typing_extensions import Annotated def main ( name : Annotated [ Optional [ str ], typer . Argument ()] = None ): if name is None : print ( "Hello World!" ) else : print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Now we have: name : Annotated [ Optional [ str ], typer . Argument ()] = None Because we are using typer.Argument() Typer will know that this is a CLI argument (no matter if required or optional ). Tip By using Optional your editor will be able to know that the value could be None , and will be able to warn you if you do something assuming it is a str that would break if it was None . Check the help: // First check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] Options: --help                Show this message and exit. Tip Notice that NAME is still a CLI argument , it's shown up there in the " Usage: main.py ...". Also notice that now [NAME] has brackets (" [ " and " ] ") around (before it was just NAME ) to denote that it's optional , not required . Now run it and test it: // With no CLI argument $ python main.py Hello World! // With one optional CLI argument $ python main.py Camila Hello Camila Tip Notice that " Camila " here is an optional CLI argument , not a CLI option , because we didn't use something like " --name Camila ", we just passed " Camila " directly to the program. Alternative (old) typer.Argument() as the default value ¬∂ Typer also supports another older alternative syntax for declaring CLI arguments with additional metadata. Instead of using Annotated , you can use typer.Argument() as the default value: import typer def main ( name : str = typer . Argument ()): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. Before, because name didn't have any default value it would be a required parameter for the Python function, in Python terms. When using typer.Argument() as the default value Typer does the same and makes it a required CLI argument . We changed it to: name : str = typer . Argument () But now as typer.Argument() is the "default value" of the function's parameter, it would mean that "it is no longer required" (in Python terms). As we no longer have the Python function default value (or its absence) to tell if something is required or not and what is the default value, typer.Argument() receives a first parameter default that serves the same purpose of defining that default value, or making it required. Not passing any value to the default argument is the same as marking it as required. But you can also explicitly mark it as required by passing ... as the default argument, passed to typer.Argument(default=...) . name : str = typer . Argument ( default =... ) Info If you hadn't seen that ... before: it is a special single value, it is part of Python and is called "Ellipsis" . import typer def main ( name : str = typer . Argument ( default =... )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) And the same way, you can make it optional by passing a different default value, for example None : from typing import Optional import typer def main ( name : Optional [ str ] = typer . Argument ( default = None )): if name is None : print ( "Hello World!" ) else : print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Because the first parameter passed to typer.Argument(default=None) (the new "default" value) is None , Typer knows that this is an optional CLI argument , if no value is provided when calling it in the command line, it will have that default value of None . The default argument is the first one, so it's possible that you see code that passes the value without explicitly using default= , like: name : str = typer . Argument ( ... ) ...or like: name : str = typer . Argument ( None ) ...but again, try to use Annotated if possible, that way your code in terms of Python will mean the same thing as with Typer and you won't have to remember any of these details. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Other uses - Typer Typer Other uses Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Other uses typer.Argument() has several other use cases. Such as for data validation, to enable other features, etc. You will see about these use cases later in the docs. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Arguments with Help - Typer Skip to content Typer CLI Arguments with Help Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Help Table of contents Add a help text for a CLI argument Combine help text and docstrings Help with defaults Custom default string Custom help name (metavar) CLI Argument help panels Help with style using Rich Hide a CLI argument from the help text Help text for CLI arguments in Click CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Add a help text for a CLI argument Combine help text and docstrings Help with defaults Custom default string Custom help name (metavar) CLI Argument help panels Help with style using Rich Hide a CLI argument from the help text Help text for CLI arguments in Click CLI Arguments with Help In the First Steps section you saw how to add help for a CLI app/command by adding it to a function's docstring . Here's how that last example looked like: import typer def main ( name : str , lastname : str = "" , formal : bool = False ): """ Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. """ if formal : print ( f "Good day Ms. { name } { lastname } ." ) else : print ( f "Hello { name } { lastname } " ) if __name__ == "__main__" : typer . run ( main ) Now that you also know how to use typer.Argument() , let's use it to add documentation specific for a CLI argument . Add a help text for a CLI argument ¬∂ You can use the help parameter to add a help text for a CLI argument : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( help = "The name of the user to greet" )]): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( ... , help = "The name of the user to greet" )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) And it will be used in the automatic --help option: $ python main.py --help // Check the section with Arguments below üöÄ Usage: main.py [OPTIONS] NAME Arguments: NAME  The name of the user to greet  [required] Options: --help                Show this message and exit. Combine help text and docstrings ¬∂ And of course, you can also combine that help with the docstring : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( help = "The name of the user to greet" )]): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( ... , help = "The name of the user to greet" )): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) And the --help option will combine all the information: $ python main.py --help // Notice that we have the help text from the docstring and also the Arguments üìù Usage: main.py [OPTIONS] NAME Say hi to NAME very gently, like Dirk. Arguments: NAME  The name of the user to greet  [required] Options: --help                Show this message and exit. Help with defaults ¬∂ If you have a CLI argument with a default value, like "World" : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( help = "Who to greet" )] = "World" ): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "World" , help = "Who to greet" )): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) It will show that default value in the help text: $ python main.py --help // Notice the [default: World] üîç Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Arguments: [NAME]  Who to greet  [default: World] Options: --help                Show this message and exit. But you can disable that if you want to, with show_default=False : Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( help = "Who to greet" , show_default = False ) ] = "World" ): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "World" , help = "Who to greet" , show_default = False )): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) And then it won't show the default value: $ python main.py --help // Notice the there's no [default: World] now üî• Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Arguments: [NAME]  Who to greet Options: --help                Show this message and exit. Technical Details In Click applications the default values are hidden by default. üôà In Typer these default values are shown by default. üëÄ Custom default string ¬∂ You can use the same show_default to pass a custom string (instead of a bool ) to customize the default value to be shown in the help text: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( help = "Who to greet" , show_default = "Deadpoolio the amazing's name" ), ] = "Wade Wilson" ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "Wade Wilson" , help = "Who to greet" , show_default = "Deadpoolio the amazing's name" ) ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) And it will be used in the help text: $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME]  Who to greet  [default: (Deadpoolio the amazing's name)] Options: --help                Show this message and exit. // See it shows "(Deadpoolio the amazing's name)" instead of the actual default of "Wade Wilson" Custom help name ( metavar ) ¬∂ You can also customize the text used in the generated help text to represent a CLI argument . By default, it will be the same name you declared, in uppercase letters. So, if you declare it as: name : str It will be shown as: NAME But you can customize it with the metavar parameter for typer.Argument() . For example, let's say you don't want to have the default of NAME , you want to have username , in lowercase, and you really want ‚ú® emojis ‚ú® everywhere: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( metavar = "‚ú®username‚ú®" )] = "World" ): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "World" , metavar = "‚ú®username‚ú®" )): print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Now the generated help text will have ‚ú®username‚ú® instead of NAME : $ python main.py --help Usage: main.py [OPTIONS] ‚ú®username‚ú® Arguments: ‚ú®username‚ú®  [default: World] Options: --help                Show this message and exit. CLI Argument help panels ¬∂ You might want to show the help information for CLI arguments in different panels when using the --help option. If you have installed Rich as described in the docs for Printing and Colors , you can set the rich_help_panel parameter to the name of the panel where you want this CLI argument to be shown: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( help = "Who to greet" )], lastname : Annotated [ str , typer . Argument ( help = "The last name" , rich_help_panel = "Secondary Arguments" ) ] = "" , age : Annotated [ str , typer . Argument ( help = "The user's age" , rich_help_panel = "Secondary Arguments" ), ] = "" , ): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( ... , help = "Who to greet" ), lastname : str = typer . Argument ( "" , help = "The last name" , rich_help_panel = "Secondary Arguments" ), age : str = typer . Argument ( "" , help = "The user's age" , rich_help_panel = "Secondary Arguments" ), ): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Then, if you check the --help option, you will see a default panel named " Arguments " for the CLI arguments that don't have a custom rich_help_panel . And next you will see other panels for the CLI arguments that have a custom panel set in the rich_help_panel parameter: $ python main.py --help <b> </b><font color="#F4BF75"><b>Usage: </b></font><b>main.py [OPTIONS] NAME [LASTNAME] [AGE]               </b> <b>                                                                     </b> Say hi to NAME very gently, like Dirk. <font color="#A5A5A1">‚ï≠‚îÄ Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#F92672">*</font>    name      <font color="#F4BF75"><b>TEXT</b></font>  Who to greet [default: None] <font color="#A6194C">[required]</font>      ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Secondary Arguments ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ   lastname      </font><font color="#A37F4E"><b>[LASTNAME]</b></font>  The last name                         ‚îÇ <font color="#A5A5A1">‚îÇ   age           </font><font color="#A37F4E"><b>[AGE]     </b></font>  The user&apos;s age                        ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> <font color="#A5A5A1">‚ï≠‚îÄ Options ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font> <font color="#A5A5A1">‚îÇ </font><font color="#A1EFE4"><b>--help</b></font>                        Show this message and exit.         ‚îÇ <font color="#A5A5A1">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font> In this example we have a custom CLI arguments panel named " Secondary Arguments ". Help with style using Rich ¬∂ In a future section you will see how to use custom markup in the help for CLI arguments when reading about Commands - Command Help . If you are in a hurry you can jump there, but otherwise, it would be better to continue reading here and following the tutorial in order. Hide a CLI argument from the help text ¬∂ If you want, you can make a CLI argument not show up in the Arguments section in the help text. You will probably not want to do this normally, but it's possible: Python 3.6+ Python 3.6+ non-Annotated import typer from typing_extensions import Annotated def main ( name : Annotated [ str , typer . Argument ( hidden = True )] = "World" ): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. import typer def main ( name : str = typer . Argument ( "World" , hidden = True )): """ Say hi to NAME very gently, like Dirk. """ print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no Arguments section at all üî• Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Options: --help                Show this message and exit. Info Have in mind that the CLI argument will still show up in the first line with Usage . But it won't show up in the main help text under the Arguments section. Help text for CLI arguments in Click ¬∂ Click itself doesn't support adding help for CLI arguments , and it doesn't generate help for them as in the " Arguments: " sections in the examples above. Not supporting help in CLI arguments is an intentional design decision in Click : This is to follow the general convention of Unix tools of using arguments for only the most necessary things, and to document them in the command help text by referring to them by name. So, in Click applications, you are expected to write all the documentation for CLI arguments by hand in the docstring . Nevertheless, Typer supports help for CLI arguments . ‚ú® ü§∑‚Äç‚ôÇ Typer doesn't follow that convention and instead supports help to make it easier to have consistent help texts with a consistent format for your CLI programs. üé® This is also to help you create CLI programs that are ‚ú® awesome ‚ú® by default . With very little code. If you want to keep Click's convention in a Typer app, you can do it with the hidden parameter as described above. Technical Details To support help in CLI arguments Typer does a lot of internal work in its own sub-classes of Click's internal classes. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Building a Package - Typer Skip to content Typer Building a Package Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Building a Package Table of contents Prerequisites Create a project Dependencies and environment Create your app Modify the README Modify your project metadata Add a "script" Install your package Try your CLI program Create a wheel package Test your wheel package Support python -m (optional) Add a __main__.py Set a program name in __main__.py Autocompletion and python -m Publish to PyPI (optional) PyPI API token Publish to PyPI Install from PyPI Generate docs with Typer CLI (optional) Publish a new version with the docs What's next Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Prerequisites Create a project Dependencies and environment Create your app Modify the README Modify your project metadata Add a "script" Install your package Try your CLI program Create a wheel package Test your wheel package Support python -m (optional) Add a __main__.py Set a program name in __main__.py Autocompletion and python -m Publish to PyPI (optional) PyPI API token Publish to PyPI Install from PyPI Generate docs with Typer CLI (optional) Publish a new version with the docs What's next Building a Package When you create a CLI program with Typer you probably want to create your own Python package. That's what allows your users to install it and have it as an independent program that they can use in their terminal. And that's also required for shell auto completion to work (unless you use your program through Typer CLI ). Nowadays, there are several ways and tools to create Python packages (what you install with pip install something ). You might even have your favorite already. Here's a very opinionated, short guide, showing one of the alternative ways of creating a Python package with a Typer app, from scratch. Tip If you already have a favorite way of creating Python packages, feel free to skip this. Prerequisites ¬∂ For this guide we'll use Poetry . Poetry's docs are great, so go ahead, check them and install it. Create a project ¬∂ Let's say we want to create a CLI application called portal-gun . To make sure your package doesn't collide with the package created by someone else, we'll name it with a prefix of your name. So, if your name is Rick, we'll call it rick-portal-gun . Create a project with Poetry: $ poetry new rick-portal-gun Created package rick_portal_gun in rick-portal-gun // Enter the new project directory cd ./rick-portal-gun Dependencies and environment ¬∂ Add typer[all] to your dependencies: $ poetry add "typer[all]" // It creates a virtual environment for your project Creating virtualenv rick-portal-gun-w31dJa0b-py3.6 in /home/rick/.cache/pypoetry/virtualenvs Using version ^0.1.0 for typer Updating dependencies Resolving dependencies... (1.2s) Writing lock file ---> 100% Package operations: 15 installs, 0 updates, 0 removals - Installing zipp (3.1.0) - Installing importlib-metadata (1.5.0) - Installing pyparsing (2.4.6) - Installing six (1.14.0) - Installing attrs (19.3.0) - Installing click (7.1.1) - Installing colorama (0.4.3) - Installing more-itertools (8.2.0) - Installing packaging (20.3) - Installing pluggy (0.13.1) - Installing py (1.8.1) - Installing shellingham (1.3.2) - Installing wcwidth (0.1.8) - Installing pytest (5.4.1) - Installing typer (0.0.11) // Activate that new virtual environment $ poetry shell Spawning shell within /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.6 // Open an editor using this new environment, for example VS Code $ code ./ You can see that you have a generated project structure that looks like: .
‚îú‚îÄ‚îÄ poetry.lock
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ README.rst
‚îú‚îÄ‚îÄ rick_portal_gun
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ __init__.py
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ test_rick_portal_gun.py Create your app ¬∂ Now let's create an extremely simple Typer app. Create a file rick_portal_gun/main.py with: import typer app = typer . Typer () @app . callback () def callback (): """ Awesome Portal Gun """ @app . command () def shoot (): """ Shoot the portal gun """ typer . echo ( "Shooting portal gun" ) @app . command () def load (): """ Load the portal gun """ typer . echo ( "Loading portal gun" ) Tip As we are creating an installable Python package, there's no need to add a section with if __name__ == "__main__": . Modify the README ¬∂ Let's change the README. By default it's a file README.rst . Let's change it to README.md . So, change the extension from .rst to .md . So that we can use Markdown instead of reStructuredText. And change the file to have something like: # Portal Gun The awesome Portal Gun Modify your project metadata ¬∂ Edit your file pyproject.toml . It would look something like: [tool.poetry] name = "rick-portal-gun" version = "0.1.0" description = "" authors = [ "Rick Sanchez <rick@example.com>" ] [tool.poetry.dependencies] python = "^3.6" typer = { extras = [ "all" ], version = "^0.1.0" } [tool.poetry.dev-dependencies] pytest = "^5.2" [build-system] requires = [ "poetry>=0.12" ] build-backend = "poetry.masonry.api" We changed the default README, so let's make it use the new README.md . Add the line: [tool.poetry] name = "rick-portal-gun" version = "0.1.0" description = "" authors = [ "Rick Sanchez <rick@example.com>" ] readme = "README.md" [tool.poetry.dependencies] python = "^3.6" typer = { extras = [ "all" ], version = "^0.1.0" } [tool.poetry.dev-dependencies] pytest = "^5.2" [build-system] requires = [ "poetry>=0.12" ] build-backend = "poetry.masonry.api" Add a "script" ¬∂ We are creating a Python package that can be installed with pip install . But we want it to provide a CLI program that can be executed in the shell. To do that, we add a configuration to the pyproject.toml in the section [tool.poetry.scripts] : [tool.poetry] name = "rick-portal-gun" version = "0.1.0" description = "" authors = [ "Rick Sanchez <rick@example.com>" ] readme = "README.md" [tool.poetry.scripts] rick-portal-gun = "rick_portal_gun.main:app" [tool.poetry.dependencies] python = "^3.6" typer = { extras = [ "all" ], version = "^0.1.0" } [tool.poetry.dev-dependencies] pytest = "^5.2" [build-system] requires = [ "poetry>=0.12" ] build-backend = "poetry.masonry.api" Here's what that line means: rick-portal-gun : will be the name of the CLI program. That's how we will call it in the terminal once it is installed. Like: $ rick-portal-gun // Something happens here ‚ú® rick_portal_gun.main , in the part "rick_portal_gun.main:app" , with underscores, refers to the Python module to import. That's what someone would use in a section like: from rick_portal_gun.main import # something goes here The app in "rick_portal_gun.main:app" is the thing to import from the module, and to call as a function, like: from rick_portal_gun.main import app app () That config section tells Poetry that when this package is installed we want it to create a command line program called rick-portal-gun . And that the object to call (like a function) is the one in the variable app inside of the module rick_portal_gun.main . Install your package ¬∂ That's what we need to create a package. You can now install it: $ poetry install Installing dependencies from lock file No dependencies to install or update - Installing rick-portal-gun (0.1.0) Try your CLI program ¬∂ Your package is installed in the environment created by Poetry, but you can already use it. // You can use the which program to check which rick-portal-gun program is available (if any) $ which rick-portal-gun // You get the one from your environment /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.6/bin/rick-portal-gun // Try it $ rick-portal-gun // You get all the standard help Usage: rick-portal-gun [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: load   Load the portal gun shoot  Shoot the portal gun Create a wheel package ¬∂ Python packages have a standard format called a "wheel". It's a file that ends in .whl . You can create a wheel with Poetry: $ poetry build Building rick-portal-gun (0.1.0) - Building sdist - Built rick-portal-gun-0.1.0.tar.gz - Building wheel - Built rick_portal_gun-0.1.0-py3-none-any.whl After that, if you check in your project directory, you should now have a couple of extra files at ./dist/ : .
‚îú‚îÄ‚îÄ dist ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ rick_portal_gun-0.1.0-py3-none-any.whl ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ rick-portal-gun-0.1.0.tar.gz ‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ ... The .whl is the wheel file. You can send that wheel file to anyone and they can use it to install your program (we'll see how to upload it to PyPI in a bit). Test your wheel package ¬∂ Now you can open another terminal and install that package from the file for your own user with: $ pip install --user /home/rock/code/rick-portal-gun/dist/rick_portal_gun-0.1.0-py3-none-any.whl ---> 100% Warning The --user is important, that ensures you install it in your user's directory and not in the global system. If you installed it in the global system (e.g. with sudo ) you could install a version of a library (e.g. a sub-dependency) that is incompatible with your system. Tip Bonus points if you use pipx to install it while keeping an isolated environment for your Python CLI programs üöÄ Now you have your CLI program installed. And you can use it freely: $ rick-portal-gun shoot // It works üéâ Shooting portal gun Having it installed globally (and not in a single environment), you can now install completion globally for it: $ rick-portal-gun --install-completion zsh completion installed in /home/user/.zshrc. Completion will take effect once you restart the terminal. Tip If you want to remove completion you can just delete the added line in that file. And after you restart the terminal you will get completion for your new CLI program: $ rick-portal-gun [ TAB ][ TAB ] // You get completion for your CLI program ‚ú® load   -- Load the portal gun shoot  -- Shoot the portal gun Support python -m (optional) ¬∂ You may have seen that you can call many Python modules as scripts with python -m some-module . For example, one way to call pip is: $ pip install fastapi But you can also call Python with the -m CLI Option and pass a module for it to execute as if it was a script, like: $ python -m pip install fastapi Here we pass pip as the value for -m , so, Python will execute the module pip as if it was a script. And then it will pass the rest of the CLI Parameters ( install fastapi ) to it. These two are more or less equivalent, the install fastapi will be passed to pip . Tip In the case of pip , in many occasions it's actually recommended that you run it with python -m , because if you create a virtual environment with its own python , that will ensure that you use the pip from that environment. Add a __main__.py ¬∂ You can support that same style of calling the package/module for your own package, simply by adding a file __main__.py . Python will look for that file and execute it. The file would live right beside __init__.py : .
‚îú‚îÄ‚îÄ poetry.lock
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ README.rst
‚îú‚îÄ‚îÄ rick_portal_gun
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py ‚îÇ   ‚îî‚îÄ‚îÄ __main__.py ‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ test_rick_portal_gun.py No other file has to import it, you don't have to reference it in your pyproject.toml or anything else, it just works by default, as it is standard Python behavior. Then in that file you can execute your Typer program: from .main import app app () Now, after installing your package, if you call it with python -m it will work (for the main part): $ python -m rick_portal_gun Usage: __main__.py [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: load   Load the portal gun shoot  Shoot the portal gun Tip Notice that you have to pass the importable version of the package name, so rick_portal_gun instead of rick-portal-gun . That works! üöÄ Sort of... ü§î See the __main__.py in the help instead of rick-portal-gun ? We'll fix that next. Set a program name in __main__.py ¬∂ We are setting the program name in the file pyproject.toml in the line like: [tool.poetry.scripts] rick-portal-gun = "rick_portal_gun.main:app" But when Python runs our package as a script with python -m , it doesn't have the information of the program name. So, to fix the help text to use the correct program name when called with python -m , we can pass it to the app in __main__.py : from .main import app app ( prog_name = "rick-portal-gun" ) Tip You can pass all the arguments and keyword arguments you could pass to a Click application, including prog_name . $ python -m rick_portal_gun Usage: rick-portal-gun [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion  Install completion for the current shell. --show-completion     Show completion for the current shell, to copy it or customize the installation. --help                Show this message and exit. Commands: load   Load the portal gun shoot  Shoot the portal gun Great! That works correctly! üéâ ‚úÖ Notice that now it uses rick-portal-gun instead of __main__.py in the help. Autocompletion and python -m ¬∂ Have in mind that TAB completion (shell auto-completion) won't work when using python -m . Auto-completion depends on the name of the program called, it's tied to each specific program name. So, to have shell completion for rick-portal-gun you would have to call it directly: $ rick-portal-gun [ TAB ][ TAB ] But you can still support python -m for the cases where it's useful. Publish to PyPI (optional) ¬∂ You can publish that new package to PyPI to make it public, so others can install it easily. So, go ahead and create an account there (it's free). PyPI API token ¬∂ To do it, you first need to configure a PyPI auth token. Login to PyPI . And then go to https://pypi.org/manage/account/token/ to create a new token. Let's say your new API token is: pypi-wubalubadubdub-deadbeef1234 Now configure Poetry to use this token with the command poetry config pypi-token.pypi : $ poetry config pypi-token.pypi pypi-wubalubadubdub-deadbeef1234 // It won't show any output, but it's already configured Publish to PyPI ¬∂ Now you can publish your package with Poetry. You could build the package (as we did above) and then publish later, or you could tell poetry to build it before publishing in one go: $ poetry publish --build # There are 2 files ready for publishing. Build anyway? ( yes/no ) [ no ] $ yes ---> 100% Building rick-portal-gun (0.1.0) - Building sdist - Built rick-portal-gun-0.1.0.tar.gz - Building wheel - Built rick_portal_gun-0.1.0-py3-none-any.whl Publishing rick-portal-gun (0.1.0) to PyPI - Uploading rick-portal-gun-0.1.0.tar.gz 100% - Uploading rick_portal_gun-0.1.0-py3-none-any.whl 100% Now you can go to PyPI and check your projects at https://pypi.org/manage/projects/ . You should now see your new "rick-portal-gun" package. Install from PyPI ¬∂ Now to see that we can install it form PyPI, open another terminal, and uninstall the currently installed package. $ pip uninstall rick-portal-gun Found existing installation: rick-portal-gun 0.1.0 Uninstalling rick-portal-gun-0.1.0: Would remove: /home/user/.local/bin/rick-portal-gun /home/user/.local/lib/python3.6/site-packages/rick_portal_gun-0.1.0.dist-info/* /home/user/.local/lib/python3.6/site-packages/rick_portal_gun/* # Proceed ( y/n ) ? $ y Successfully uninstalled rick-portal-gun-0.1.0 And now install it again, but this time using just the name, so that pip pulls it from PyPI: $ pip install --user rick-portal-gun // Notice that it says "Downloading" üöÄ Collecting rick-portal-gun Downloading rick_portal_gun-0.1.0-py3-none-any.whl (1.8 kB) Requirement already satisfied: typer[all]<0.0.12,>=0.0.11 in ./.local/lib/python3.6/site-packages (from rick-portal-gun) (0.0.11) Requirement already satisfied: click<7.2.0,>=7.1.1 in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (7.1.1) Requirement already satisfied: colorama; extra == "all" in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (0.4.3) Requirement already satisfied: shellingham; extra == "all" in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (1.3.1) Installing collected packages: rick-portal-gun Successfully installed rick-portal-gun-0.1.0 And now test the newly installed package from PyPI: $ rick-portal-gun load // It works! üéâ Loading portal gun Generate docs with Typer CLI (optional) ¬∂ You can install and use Typer CLI to generate docs for your package. After installing it, you can use it to generate a new README.md : $ typer rick_portal_gun.main utils docs --output README.md --name rick-portal-gun Docs saved to: README.md You just have to pass it the module to import ( rick_portal_gun.main ) and it will detect the typer.Typer app automatically. By specifying the --name of the program it will be able to use it while generating the docs. Publish a new version with the docs ¬∂ Now you can publish a new version with the updated docs. For that you need to first increase the version in pyproject.toml : [tool.poetry] name = "rick-portal-gun" version = "0.2.0" description = "" authors = [ "Rick Sanchez <rick@example.com>" ] readme = "README.md" [tool.poetry.scripts] rick-portal-gun = "rick_portal_gun.main:app" [tool.poetry.dependencies] python = "^3.6" typer = { extras = [ "all" ], version = "^0.1.0" } [tool.poetry.dev-dependencies] pytest = "^5.2" [build-system] requires = [ "poetry>=0.12" ] build-backend = "poetry.masonry.api" And in the file rick_portal_gun/__init__.py : __version__ = '0.2.0' And then build and publish again: $ poetry publish --build ---> 100% Building rick-portal-gun (0.2.0) - Building sdist - Built rick-portal-gun-0.2.0.tar.gz - Building wheel - Built rick_portal_gun-0.2.0-py3-none-any.whl Publishing rick-portal-gun (0.2.0) to PyPI - Uploading rick-portal-gun-0.2.0.tar.gz 100% - Uploading rick_portal_gun-0.2.0-py3-none-any.whl 100% And now you can go to PyPI, to the project page, and reload it, and it will now have your new generated docs. What's next ¬∂ This is a very simple guide. You could add many more steps. For example, you should use Git , the version control system, to save your code. You can add a lot of extra metadata to your pyproject.toml , check the docs for Poetry: Libraries . You could use pipx to manage your installed CLI Python programs in isolated environments. Maybe use automatic formatting with Black . You'll probably want to publish your code as open source to GitHub . And then you could integrate a CI tool to run your tests and deploy your package automatically. And there's a long etc. But now you have the basics and you can continue on your own üöÄ. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Multiple Values Intro - Typer Typer Multiple Values Intro Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Multiple Values Intro There are several ways to declare multiple values for CLI options and CLI arguments . We'll see them in the next short sections. Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

Multiple CLI Options - Typer Skip to content Typer Multiple CLI Options Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options Multiple CLI Options Table of contents Multiple float CLI Options with Multiple Values CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Multiple float Multiple CLI Options You can declare a CLI option that can be used multiple times, and then get all the values. For example, let's say you want to accept several users in a single execution. For this, use the standard Python typing.List to declare it as a list of str : Python 3.6+ Python 3.6+ non-Annotated from typing import List , Optional import typer from typing_extensions import Annotated def main ( user : Annotated [ Optional [ List [ str ]], typer . Option ()] = None ): if not user : print ( "No provided users" ) raise typer . Abort () for u in user : print ( f "Processing user: { u } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import List , Optional import typer def main ( user : Optional [ List [ str ]] = typer . Option ( None )): if not user : print ( "No provided users" ) raise typer . Abort () for u in user : print ( f "Processing user: { u } " ) if __name__ == "__main__" : typer . run ( main ) You will receive the values as you declared them, as a list of str . Check it: $ python main.py No provided users Aborted! // Now pass a user $ python main.py --user Camila Processing user: Camila // And now try with several users $ python main.py --user Camila --user Rick --user Morty Processing user: Camila Processing user: Rick Processing user: Morty Multiple float ¬∂ The same way, you can use other types and they will be converted by Typer to their declared type: Python 3.6+ Python 3.6+ non-Annotated from typing import List import typer from typing_extensions import Annotated def main ( number : Annotated [ List [ float ], typer . Option ()] = []): print ( f "The sum is { sum ( number ) } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import List import typer def main ( number : List [ float ] = typer . Option ([])): print ( f "The sum is { sum ( number ) } " ) if __name__ == "__main__" : typer . run ( main ) Check it: $ python main.py The sum is 0 // Try with some numbers $ python main.py --number 2 The sum is 2.0 // Try with some numbers $ python main.py --number 2 --number 3 --number 4 .5 The sum is 9.5 Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Options with Multiple Values - Typer Skip to content Typer CLI Options with Multiple Values Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Options with Multiple Values Table of contents Check it CLI Arguments with Multiple Values Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents Check it CLI Options with Multiple Values You can also declare a CLI option that takes several values of different types. You can set the number of values and types to anything you want, but it has to be a fixed number of values. For this, use the standard Python typing.Tuple : Python 3.6+ Python 3.6+ non-Annotated from typing import Tuple import typer from typing_extensions import Annotated def main ( user : Annotated [ Tuple [ str , int , bool ], typer . Option ()] = ( None , None , None )): username , coins , is_wizard = user if not username : print ( "No user provided" ) raise typer . Abort () print ( f "The username { username } has { coins } coins" ) if is_wizard : print ( "And this user is a wizard!" ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import Tuple import typer def main ( user : Tuple [ str , int , bool ] = typer . Option (( None , None , None ))): username , coins , is_wizard = user if not username : print ( "No user provided" ) raise typer . Abort () print ( f "The username { username } has { coins } coins" ) if is_wizard : print ( "And this user is a wizard!" ) if __name__ == "__main__" : typer . run ( main ) Each of the internal types defines the type of each value in the tuple. So: user : Tuple [ str , int , bool ] means that the parameter user is a tuple of 3 values. The first value is a str . The second value is an int . The third value is a bool . Later we do: username , coins , is_wizard = user If you hadn't seen that, it means that user is a tuple with 3 values, and we are assigning each of the values to a new variable: The first value in the tuple user (a str ) goes to the variable username . The second value in the tuple user (an int ) goes to the variable coins . The third value in the tuple user (a bool ) goes to the variable is_wizard . So, this: username , coins , is_wizard = user is equivalent to this: username = user [ 0 ] coins = user [ 1 ] is_wizard = user [ 2 ] Tip Notice that the default is a tuple with (None, None, None) . You cannot simply use None here as the default because Click doesn't support it . Check it ¬∂ Now let's see how this works in the terminal: // check the help $ python main.py --help // Notice the &lt;TEXT INTEGER BOOLEAN&gt; Usage: main.py [OPTIONS] Options: --user &lt;TEXT INTEGER BOOLEAN&gt;... --help                          Show this message and exit. // Now try it $ python main.py --user Camila 50 yes The username Camila has 50 coins And this user is a wizard! // With other values $ python main.py --user Morty 3 no The username Morty has 3 coins // Try with invalid values (not enough) $ python main.py --user Camila 50 Error: --user option requires 3 arguments Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?

CLI Arguments with Multiple Values - Typer Skip to content Typer CLI Arguments with Multiple Values Initializing search tiangolo/typer Typer tiangolo/typer Typer Features Tutorial - User Guide Tutorial - User Guide Tutorial - User Guide - Intro First Steps Printing and Colors Terminating CLI Arguments CLI Arguments CLI Arguments Intro Optional CLI Arguments CLI Arguments with Default CLI Arguments with Help CLI Arguments with Environment Variables Other uses CLI Options CLI Options CLI Options Intro CLI Options with Help Required CLI Options CLI Option Prompt Password CLI Option and Confirmation Prompt CLI Option Name CLI Option Callback and Context Version CLI Option, is_eager Commands Commands Commands Intro Command CLI Arguments Command CLI Options Command Help Custom Command Name Typer Callback One or Multiple Commands Using the Context CLI Option autocompletion CLI Parameter Types CLI Parameter Types CLI Parameter Types Intro Number Boolean CLI Options UUID DateTime Enum - Choices Path File Custom Types SubCommands - Command Groups SubCommands - Command Groups SubCommands - Command Groups - Intro Add Typer SubCommands in a Single File Nested SubCommands Sub-Typer Callback Override SubCommand Name and Help Multiple Values Multiple Values Multiple Values Intro Multiple CLI Options CLI Options with Multiple Values CLI Arguments with Multiple Values CLI Arguments with Multiple Values Table of contents CLI arguments with tuples Ask with Prompt Progress Bar CLI Application Directory Launching Applications Testing Using Click Building a Package Exceptions and Errors Typer CLI - completion for small scripts Alternatives, Inspiration and Comparisons Help Typer - Get Help Development - Contributing Release Notes Table of contents CLI arguments with tuples CLI Arguments with Multiple Values CLI arguments can also receive multiple values. You can define the type of a CLI argument using typing.List . from pathlib import Path from typing import List import typer def main ( files : List [ Path ], celebration : str ): for path in files : if path . is_file (): print ( f "This file exists: { path . name } " ) print ( celebration ) if __name__ == "__main__" : typer . run ( main ) And then you can pass it as many CLI arguments of that type as you want: $ python main.py ./index.md ./first-steps.md woohoo! This file exists: index.md woohoo! This file exists: first-steps.md woohoo! Tip We also declared a final CLI argument celebration , and it's correctly used even if we pass an arbitrary number of files first. Info A List can only be used in the last command (if there are subcommands), as this will take anything to the right and assume it's part of the expected CLI arguments . CLI arguments with tuples ¬∂ If you want a specific number of values and types, you can use a tuple, and it can even have default values: Python 3.6+ Python 3.6+ non-Annotated from typing import Tuple import typer from typing_extensions import Annotated def main ( names : Annotated [ Tuple [ str , str , str ], typer . Argument ( help = "Select 3 characters to play with" ) ] = ( "Harry" , "Hermione" , "Ron" ) ): for name in names : print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Tip Prefer to use the Annotated version if possible. from typing import Tuple import typer def main ( names : Tuple [ str , str , str ] = typer . Argument ( ( "Harry" , "Hermione" , "Ron" ), help = "Select 3 characters to play with" ) ): for name in names : print ( f "Hello { name } " ) if __name__ == "__main__" : typer . run ( main ) Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAMES]... Arguments: [NAMES]...  Select 3 characters to play with  [default: Harry, Hermione, Ron] Options: --help                Show this message and exit. // Use it with its defaults $ python main.py Hello Harry Hello Hermione Hello Ron // If you pass an invalid number of arguments you will get an error $ python main.py Draco Hagrid Error: argument names takes 3 values // And if you pass the exact number of values it will work correctly $ python main.py Draco Hagrid Dobby Hello Draco Hello Hagrid Hello Dobby Made with Material for MkDocs Insiders You can ask questions about Typer. Try: How can I terminate a program? How to launch applications? How to add help to CLI argument?
